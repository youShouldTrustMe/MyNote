# 概述

## 计算机基本工作原理

### 冯诺依曼结构

硬件模型基本结构

![冯诺依曼结构](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/6_11_15_6_202408061115430.png)

*模型中包含`以下四个部分`*

1. 用来存放指令和数据的主存储器，简称==主存或内存==；
2. 用来进行算术逻辑运算的部件，即算术逻辑部件(Arithmetic Logic Unit,简称==ALU==),在ALU操作控制
   信号ALUop的控制下，ALU可以对输人端A和B进行不同的运算，得到结果F;
3. 用于自动逐条取出指令并进行译码的部件，即控制部件(Control Unit,简称CU),也称==控制器==；
4. 用来和用户交互的==输入设备和输出设备==。

*CPU内部`不同的组件`*

- 为了临时存放从主存取来的数据或运算的结果，还需要若干通用寄存器(General Purpose Register)组成通用寄存器组(==GPRs==)，ALU两个输入端A和B的数据来自通用寄存器；
- ALU运算的结果会产生标志信息，例如，结果是否为0（零标志ZF)、是否为负数（符号标志SF)等，这些标志信息需要记录在专门的==标志寄存器==中；
- 从主存取来的指令需要临时保存在指令寄存器(Instruction Register,简称==IR==)中；
- CPU为了自动按序读取主存中的指令，还需要有一个程序计数器(Program Counter,简称==PC==),在执行当前指令过程中，自动
  计算出下一条指令的地址并送到PC中保存。
- 通常把控制部件、运算部件和各类寄存器互连组成的电路称为中央处理器(Central Processing Unit,简称CPU),简称处理器。

*CPU读取数据`过程`*

CPU需要从通用寄存器中取数据到ALU运算，或把ALU运算的结果保存到通用寄存器中，因此，需要给每个通用寄存器编号；

同样，主存中每个单元也需要编号，称为主存单元地址，简称主存地址。

通用寄存器和主存都属于存储部件，通常，计算机中的存储部件从0开始编号，例如，4个通用寄存器编号分别为0 ~ 3；16个主存单元编号分别为0 ~ 15。

CPU为了从主存取指令和存取数据，需要通过传输介质与主存相连，通常把连接不同部件进行信息传输的介质称为==总线==，其中，包含了用于传输地址信息、数据信息和控制信息的地址线、数据线和控制线。

CPU访问主存时，需先将主存地址、读/写命令分别送到总线的地址线、控制线，然后通过数据线发送或接收数据。CPU送到地址线的主存地址应先存放在主存地址寄存器(Memory Address Register,简称==MAR==)中，发送到或从数据线取来的信息存放在主存数据寄存器(Memory Data Register,简称==MDR==)中。

### 程序和指令的执行过程

指令(instruction)是用0和1表示的一串0/1序列，用来指示CPU完成一个特定的原子操作。例如，

- 取数指令(load)从主存单元中取出数据存放到通用寄存器中；
- 存数指令（store)将通用寄存器的内容写入主存单元；
- 加法指令(add)将两个通用寄存器内容相加后送入结果寄存器；
- 传送指令(mov)将一个通用寄存器的内容送到另一个通用寄存器；

指令通常被划分为若干个字段，有操作码、地址码等字段。

- 操作码字段指出指令的操作类型，如取数、存数、加、减、传送、跳转等；
- 地址码字段指出指令所处理的操作数的地址，如寄存器编号、主存单元编号等。

指令格式如下

![指令格式](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240806114032968.png)

实现一个程序的过程

![实现程序的过程](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/6_11_41_21_202408061141156.png)

“存储程序”工作方式规定，程序执行前，需将程序包含的指令和数据先送入主存，一旦启动程序执行，则计算机必须能够在不需操作人员干预下自动完成逐条指令取出和执行的任务。

一个程序的执行就是周而复始地执行一条一条指令的过程。每条指令的执行过程包括：从主存取指令、对指令进行译码、PC增量（图中的PC+“1”表示PC的内容加上当前这一条指令的长度)、取操作数并执行、将结果送主存或寄存器保存。
程序执行前，首先将程序的起始地址存放在PC中，取指令时，将PC的内容作为地址访问主存。每条指令执行过程中，都需要计算下条将执行指令的主存地址，并送到PC中。若当前指令为顺序型指令，则下条指令地址为PC的内容加上当前指令的长度；若当前指令为跳转型指令，则下条指令地址为指令中指定的目标地址。当前指令执行完后，根据PC的值到主存中取到的是下条将要执行的指令，因而计算机能够周而复始地自动取出并执行一条一条指令。

![程序执行过程](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/6_11_43_9_202408061143902.png)



## 程序的开发与运行

### 程序设计语言和翻译程序

从抽象层次上来分，可以分成高级语言和低级语言两类。

- 使用特定计算机规定的指令格式而形成的0/1序列称为==机器语言==，计算机能理解和执行的程序称为机器代码或机器语言程序，其中的每条指令都由0和1组成，称为==机器指令==。
- 用简短的英文符号和机器指令建立对应关系，以方便程序员编写和阅读程序。这种语言称为==汇编语言==(assembly language),机器指令对应的符号表示称为汇编指令。如机器指令“11100110”对应的汇编指令为“lod0,6#”。

汇编语言和机器语言都属于低级语言，它们统称为机器级语言。

高级程序设计语言(high level programming language)简称高级编程语言，是指面向算法设计的、较接近于日常英语书面语言的程序设计语言，如BASIC、CC++、Fortran、Java等。它与具体的机器结构无关，同一个功能机器级语言表示需5条指令，而高级编程语言表示只需一条语句“z=x+y;”即可。

不过，因为计算机无法直接理解和执行高级编程语言程序，所以需要将高级编程语言程序转换成机器语言程序。因为这个转换过程是计算机自动完成的，所以把进行这种转换的软件统称为翻译程序(translator)。通常，程序员借助程序设计语言处理系统来开发软件。任何一个语言处理系统中，都包含翻译程序，它能把一种编程语言表示的程序转换为等价的另一种编程语言程序。被翻译的语言和程序分别称为==源语言和源程序==，翻译生成的语言和程序分别称为目标语言和目标程序。翻译程序有以下三类。

1. 汇编程序(assembler):也称汇编器，实现将汇编语言源程序翻译成机器语言目标程序。
2. 解释程序(interpreter)：也称解释器，实现将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行。
3. 编译程序(compiler)：也称编译器，实现将高级语言源程序翻译成汇编语言或机器语言目标程序。

![不同语言之间的转换](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/6_11_56_1_202408061156982.png)

### 从源程序到可执行程序

现有以下程序

```c
#include stdio.h>
int main()
{
    printf("hello,world\n");
}
```

为了让计算机能够执行以上程序，需要按照以下的步骤进行操作

1. 通过程序编辑软件得到hello.c文件。hello.c在计算机中以ASCI字符方式存放，图中给出了每个字符对应的ASCⅡ码的十进制值。例如，第一个字节的值是35，代表字符‘#’；第二个字节的值是105，代表字符‘i’；最后一个字节的值为125，代表字符‘}’。通常把用ASCI码字符或汉字字符表示的文件称为文本文件(text file),源程序文件都是文本文件，是可显示和可读的。

![程序在计算机中的存放](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/6_13_28_56_202408061328662.png)

2. 将hello.c进行预处理、编译、汇编和链接，最终生成可执行目标文件。例如，在UNIX系统中，可用GCC编译驱动程序进行处理，命令如下：

   ```shell
   gcc -o hello hello.c
   ```

   上面的一行命令实际上计算机进行了以下的操作

   ![源程序到可执行文件的转换顺序](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/6_13_33_27_202408061333866.png)

*预处理`阶段`*：预处理程序（cpp)对源程序中以字符#开头的命令进行处理，例如，将#include命令后面的.h文件内容嵌入到源程序文件中。预处理程序的输出结果还是一个源程序文件，以.i为扩展名。

*编译`阶段`*：编译程序(cc1)对预处理后的源程序进行编译，生成一个汇编语言源程序文件，以.s为扩展名，例如，hello.s是一个汇编语言源程序文件。因为汇编语言与具体的机器结构有关，所以，对同一台机器来说，不管何种高级语言，编译转换后的输出结果都是同一种机器语言对应的汇编语言源程序。

*汇编`阶段`*：汇编程序(as)对汇编语言源程序进行汇编，生成一个==可重定位目标文件==(relocatable object file),以.o为扩展名，例如，hello.o是一个可重定位目标文件。它是一种二进制文件(binary file),因为其中的代码已经是机器指令，数据以及其他信息也都是用二进制表示的，所以它是不可读的，也即打开显示出来的是乱码。

*链接`阶段`*：链接程序(ld)将多个可重定位目标文件和标准函数库中的可重定位目标文件合并成为一个==可执行目标文件==(executable object file),可执行目标文件简称为可执行文件。本例中，链接器将hello.o和标准库函数printf所在的可重定位目标模块printf.o进行合并，生成可执行文件hello。

最终生成的可执行文件被保存在磁盘上，可以通过某种方式启动一个磁盘上的可执行文件运行。

### 可执行文件的启动和运行

对于一个存放在磁盘上的可执行文件，可以在操作系统提供的用户操作环境中，采用双击对应图标或在命令行中输人可执行文件名等多种方式来启动执行。在UNIX系统中，可以通过shell命令行解释器来执行一个可执行文件。

![启动和执行程序的过程](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/6_13_43_38_202408061343424.png)

1. shell程序会将用户从键盘输入的每个字符逐一读入CPU寄存器中（对应线①)，
2. 然后再保存到主存储器中，在主存的缓冲区形成字符串"./hello"(对应线②)。
3. 等到接收到[Enter]按键时，shell将调出操作系统内核中相应的服务例程，由内核来加载磁盘上的可执行文件hello到存储器（对应线③）。
4. 内核加载完可执行文件中的代码及其所要处理的数据（这里是字符串"hello,world\n")后，将hello第一条指令的地址送到程序计数器(PC)中，CPU永远都是将PC的内容作为将要执行的指令的地址，因此，处理器随后开始执行hello程序，它将加载到主存的字符串"hello,word\n”中的每一个字符从主存取到CPU的寄存器中(对应线④)，
5. 然后将CPU寄存器中的字符送到显示器上显示出来（对应线⑤）。

从上述过程可以看出，一个用户程序被启动执行，==必须依靠操作系统==的支持，包括提供人机接口环境（如外壳程序）和内核服务例程。

例如，shell命令行解释器是操作系统外壳程序，它为用户提供了一个启动程序执行的环境，用来对用户从键盘输入的命令进行解释，并调出操作系统内核来加载用户程序（用户从键盘输人的命令所对应的程序）。显然，用来加载用户程序并使其从第一条指令开始执行的操作系统内核服务例程也是必不可少的。

此外，在上述过程中，涉及键盘、磁盘和显示器等外部设备的操作，这些底层硬件是不能由用户程序直接访问的。此时，也需要依靠操作系统内核服务例程的支持，例如，用户程序需要调用内核的read系统调用服务例程读取磁盘文件，或调用内核的write系统调用服务例程把字符串“写”到显示器等。

键盘、磁盘和显示器等外部设备简称为==外设==，也称为I/O设备，其中，I/O是输入/输出(Input/Output)的缩写。外设通常由机械部分和电子部分组成，并且两部分通常是可以分开的。机械部分是外部设备本身，而电子部分则是控制外部设备工作的I/O控制器或I/O适配器。

外设通过I/O控制器或I/O适配器连接到主机上，I/O控制器或I/O适配器统称为设备控制器。例如，键盘接口、打印机适配器、显示控制卡（简称显卡）、网络控制卡（简称网卡）等都是一种设备控制器，属于一种I/O模块。

> [!NOTE]
>
> 程序的执行过程就是数据在CPU、主存储器和I/O模块之间流动的过程，所有数据的流动都是通过总线、I/O桥接器等进行的。数据在总线上传输之前，需要先缓存在存储部件中，因此，除了主存本身是存储部件以外，在CPU、I/O桥接器、设备控制器中也有存放数据的缓冲存储部件，例如，CPU中的通用寄存器，设备控制器中的数据缓冲寄存器等。



# 程序的链接

## 编译、汇编

### 编译和汇编

以GCC处理C语言程序为例来说明处理过程。可以通过-ⅴ选项查看GCC每一步的处理结果。如果想得到每个处理过程的结果，则可以分别使用==-E、-S和-c==选项来进行预处理、编译和汇编，对应的处理工具分别为==cpp、ccl和as==,处理后得到的文件的文件名后缀分别是.i、.s和.o。

*预处理`阶段`*

预处理是从源程序变成可执行程序的第一步，C预处理程序为==cpp==（即C Preprocessor),主要用于C语言编译器对各种预处理命令进行处理，包括对头文件的包含、宏定义的扩展、条件编译的选择等，例如，对于#include指示的处理结果，就是将相应h文件的内容插入到源程序文件中。

```shell
gcc -E main.c -o main.i	#gcc -E
cpp main.c -o main.i	#cpp
```

用以上两行代码都可以将c文件转换为i文件，预处理后的文件是可显示的文本文件

*编译`阶段`*

C编译器在进行具体的程序翻译之前，会先对源程序进行词法分析、语法分析和语义分析，然后根据分析的结果进行代码优化和存储分配，最终把C语言源程序翻译成汇编语言程序。

编译器通常采用对源程序进行多次扫描的方式进行处理，每次扫描集中完成一项或几项任务，也可以将一项任务分散到几次扫描去完成。

例如，可以按照以下四趟扫描进行处理：

1. 第一趟扫描进行词法分析；
2. 第二趟扫描进行语法分析；
3. 第三趟扫描进行代码优化和存储分配；

4. 第四趟扫描生成代码。

GCC可以直接产生机器语言代码，也可以先产生汇编语言代码，然后再通过汇编程序将汇编语言代码转换为机器语言代码。

```shell
gcc-S main.i-o main.s
ccl main.i-o main.s
或者
gcc-S main.c-o main.s
gcc-S main.c
```

*汇编`阶段`*

汇编的功能是将编译生成的汇编语言代码转换为机器语言代码。因为通常最终的可执行目标文件由多个不同模块对应的机器语言目标代码组合而形成，所以，在生成单个模块的机器语言目标代码时，不可能确定每条指令或每个数据最终的地址，也即，单个模块的机器语言目标代码需要重新定位，因此，通常把汇编生成的机器语言目标代码文件称为可重定位目标文件。

```shell
gcc -c main.s -o main.o
as main.s -o main.o
或者
gcc -c main.c -o main.o
gcc -c main.c
```

### 可执行目标文件的生成

链接的功能是将所有关联的可重定位目标文件组合起来，以生成一个可执行文件。例如，对下面的两个模块main.c和test.c。

---

> main.c
>
> ```c
> int add(int,int);
> int main()
> {
>        return add(20,13);
> }
> ```

> test.c
>
> ```c
> int add(int i,int j)
> {
>        int x=i+j;
>        return x;
> }
> ```

假定通过预处理、编泽和汇编，分别生成了可重定位目标文件main.o和test.o,则可以

```shell
gcc -o test main.o test.o
ld -o test main.o test.o
```

用以上的任意一个命令都可以生成可执行文件test。这里，ld是静态链接器命令。

![静态链接图示](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/6_15_41_27_202408061541929.png)

可重定位目标文件和可执行目标文件都是机器语言目标文件，所不同的是前者是单个模块生成的，而后者是多个模块组合而成的。因而，对于前者，代码总是从0开始的，而对于后者代码则是从ABI规范规定的虚拟地址空间中产生。

可以使用objdump来反汇编程序

```shell
objdump -d test.o
```

test.o的反汇编结果如下

```assembly
00000000<add>:
0:55		push	%ebp
1:89e5		mov		%esp,%ebp
3:83ec10	sub		$0x10,%esp
6:8b450c	mov		0xc(%ebp )%eax
9:8b5508	mov		0x8(%ebp),%edx
C:8d0402	lea		(%edx,%eax,1),%eax
f:8945fc	mov		%eax,-0x4(%ebp)
12:8b45fc	mov		-0x4(%ebp),%eax
15:c9		leave
16:c3		ret
```

test的反汇编结果如下

```assembly
080483d4<add>:
80483d4:55		push	%ebp
80483d5:89e5	mov		%esp,%ebp
80483d7:83ec10	sub		$0x10,%esp
80483da:8b450c	mov		Oxc(%ebp),%eax
80483dd:8b5508	mov		0x8(%ebp),%edx
80483e0:8d0402	lea		(%edx,%eax,1),%eax
80483e3:8945fc	mov		%eax,-0x4(%ebp)
80483e6:8b45fc	mov		-0x4(%ebp),%eax
80483e9:c9		leave
80483ea:c3		ret
```

上述给出的通过objdump命令输出的结果包括指令的地址、指令机器代码和反汇编出来的汇编指令代码。可以看出，在可重定位目标文件test.o中add函数的起始地址为==0==；而在可执行目标文件test中add函数的起始地址为==0x80483d4==。

实际上，可重定位目标文件和可执行目标文件都不是可以直接显示的文本文件，而是不可显示的二进制文件，它们都按照一定的格式以二进制字节序列构成一种目标文件，其中包含

- 二进制代码区
- 只读数据区
- 已初始化数据区
- 未初始化数据区
- 等

而每个信息区称为一个==节==(section)

- ==代码节==(.text)
- ==只读数据节==(.rodata)
- ==已初始化全局数据节==(.data)
- ==未初始化全局数据节==(.bss)
- 等

静态链接器将多个可重定位目标文件合成一个可执行目标文件，主要完成以下==两个任务==。

1. ==符号解析==
   符号解析的目的是将每个符号的引用与一个确定的符号定义建立关联。符号包括全局静态变量名和函数名，而非静态局部变量名则不是符号。例如，对于例子中的两个源程序文件main.c和test.c,在main.c中定义了符号main,并引用了符号add;在test.c中则定义了符号add,而i、j和x都不是符号。链接时需要将main.o中引用的符号add和test.o中定义的符号add建立关联。对于全局变量声明`int *xp = &x;`，,可看成引用符号x对符号xp进行定义。编译器将所有符号存放在可重定位目标文件的符号表中。

2. ==重定位==
   可重定位目标文件中的代码区和数据区都是从地址0开始的，链接器需要将不同模块中相同的节合并起来生成一个新的单独的节，并将合并后的代码区和数据区按照ABI规范确定的虚拟地址空间划分（也称存储器映像)来重新确定位置。例如，对于32位Linux系统存储器映像，其只读代码段总是从地址0x8048000开始，而可读可写数据段总是在代码段后面的第一个4KB对齐的地址处开始。因而链接器需要重新确定每条指令和每个数据的地址，并且在指令中需要明确给定所引用符号的地址，这种重新确定代码和数据的地址并更新指令中被引用符号地址的工作称为==重定位==(relocation)。

## 目标文件格式

> [!NOTE]
>
> 注意：window和Unix（Linux）的相关文件的后缀和组成格式均不同
>
> 1. window文件后缀
>    1. 动态库文件：dll
>    2. 静态库文件：lib
>    3. 可重定位文件：obj
>    4. 可执行文件：exe
> 2. Linux文件后缀
>    1. 动态库文件：so
>    2. 静态库文件：a
>    3. 可重定位文件：o
>    4. 可执行文件：一般没有特定的后缀，elf是其中的一种

### ELF目标文件格式

目标文件既可用于程序的链接，也可用于程序的执行。

*链接`视图`*主要由不同的节(section)组成，节是ELF文件中具有相同特征的最小可处理信息单位，不同的节描述了目标文件中不同类型的信息及其特征，例如，代码节(.text)、只读数据节(.rodata)、已初始化全局数据节(.data)、未初始化全局数据节(.bss)等。

*执行`视图`*主要由不同的段(segment)组成，描述了目标文件中的节如何映射到存储空间的段中。可以将多个节合并后映射到同一个段，例如，可以合并节.data和节.bss的内容，并映射到一个可读可写数据段中。

![ELF目标文件的两种视图](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/6_16_15_14_202408061615881.png)



前面提到通过预处理、编译和汇编三个步骤后，可生成可重定位目标文件，多个关联的可重定位目标文件经过链接后生成可执行目标文件。这两类目标文件对应的ELF视图不同，显然，可重定位目标文件对应链接视图，而可执行目标文件对应执行视图。

节头表包含文件中各节的说明信息，每个节在该表中都有一个与之对应的项，每一项都指定了节名和节大小之类的信息。用于链接的目标文件必须具有==节头表==，例如，可重定位目标文件就一定要有节头表。程序头表用来指示系统如何创建进程的存储器映像。用于创建进程存储器映像的可执行文件和共享库文件必须具有程序头表，而可重定位目标文件不需要程序头表。

### 可重定位目标文件格式

可重定位目标文件主要包含代码部分和数据部分，它可以与其他可重定位目标文件链接，从而创建可执行目标文件、共享库文件。ELF可重定位目标文件由ELF头、节头表以及夹在ELF头和节头表之间的各个不同的节组成。

- ELF头中包含的是该文件的一些基本信息，比如是什么格式的文件，在节头表中有几项表等等
- 节中包含了代码中具体的数据及text
- 节头表提供了指向每个节的信息，因此链接器和加载器可以使用这些信息来定位和处理文件的各个部分。

![ELF可重定位目标文件格式](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/11_10_40_24_202408111040643.png)



#### ELF头

ELF头位于目标文件的起始位置，包含文件结构说明信息。ELF头的数据结构分32位系统对应结构和64位系统对应结构。以下是32位系统对应的数据结构，共占52字节。

```c
#define EI_NIDENT 16
typedef struct
{ 
    unsigned char eident[EI_NIDENT];
    E1f32_Half		  e_type;
    Elf32_Half        e_machine;
    Elf32_Word        e_version;
    E1f32_Addr        e_entry;
    E1f32_Off         e_phoff;
    E1f32_Off         e_shoff;
    Elf32_Word        e_flags;
    Elf32_Half        e_ehsize;
    Elf32_Half        e_phentsize;
    Elf32_Half        ephnum;
    Elf32_Half        e_shentsize;
    Elf32_Half        e_shnum;
    E1f32_Half        eshstrndx;
}Elf32_Ehdr;
```

- 文件开头几个字节称为==魔数==，通常用来确定文件的类型或格式。在加载或读取文件时，可用魔数确认文件类型是否正确。在32位ELF头的数据结构中，字段e_ident是一个长度为16的字节序列，
  - eident最开始的4字节为魔数，用来标识是否为ELF文件，
  - 第一个字节为0x7F,后面三个字节分别为’E‘、’L'、‘F’。
  - 再后面的12个字节中，主要包含一些标识信息，例如，标识是32位还是64位格式、标识数据按小端还是大端方式存放、标识ELF头的版本号等。

- 字段e_type用于说明目标文件的类型是可重定位文件、可执行文件、共享库文件，还是其他类型文件。
- 字段e_machine用于指定机器结构类型，如IA-32、SPARC V9、AMD64等。
- 字段e_version用于标识目标文件版本。
- 字段e_entry用于指定系统将控制权转移到的起始虚拟地址(入口点)，如果文件没有关联的入口点，则为零。例如，对于可重定位文件，此字段为0。
- 字段e_ehsize用于说明ELF头的大小（以字节为单位）。
- 字段e_shoff指出节头表在文件中的偏移量（以字节为单位）。
- 字段e_shentsize表示节头表中一个表项的大小（以字节为单位)，所有表项大小相同。
- 字段e_shnum表示节头表中的项数。因此e_shentsize和e_shnum共同指定了节头表的大小（以字节为单位）。仅ELF头在文件中具有固定位置，即总是在最开始的位置，其他部分的位置由ELF头和节头表指出，不需要具有固定的顺序。

可以使用`readelf -h`命令对某个可重定位目标文件的ELF头进行解析。例如，以下是通过“readelf-h main.o”对某main.o文件进行解析的结果。

```c
ELF Header:
Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
Class: ELF32
Data: 2's complement,little endian
Version: 1 (current)
OS/ABI: UNIX System V
ABI Version: 0
Type: REL (Relocatable file)
Machine: Inte180386
Version:0x1
Entry point address: 0x0
Start of program headers:0 (bytes into file)
Start of section headers:516 (bytes into file)
Flags: x0
Size of this header:52(bytes)
Size of program headers:0 (bytes)
Number of program headers:0
Size of section headers:40 (bytes)
Number of section headers:15
Section header string table index:12
```

从上述解析结果可以看出，该main.o文件中，ELF头长度(e_ehsize)为52字节，因为是可重定位文件，所以字段e_entry(Entry point address)为0,无程序头表(Size of program headers=0)。节头表离文件起始处的偏移(e_shoff)为516字节，每个表项大小(e_shentsize)占40字节，表项(e_shnum)为15个。字符串表(.strtab节)在节头表中的索引（e_shstrnd)12。

#### 节

节(section)是ELF文件中的主体信息，包含了链接过程所用的目标代码信息，包括指令、数据、符号表和重定位信息等。一个典型的ELF可重定位目标文件中包含下面几个节。

- *`.text`*:目标代码部分。

- *`.rodata`*:只读数据，如printf语句中的格式串、开关语句（如switch-case)的跳转表等。

- *`.data`*:已初始化的全局变量。

- *`.bss`*:未初始化的全局变量。因为未初始化变量没有具体的值，所以无须在目标文件中分配用于保存值的空间，也即它在目标文件中不占据实际的磁盘空间，仅仅是一个占位符。目标文件中区分已初始化和未初始化全局变量是为了提高空间利用率。

  - > [!NOTE]
    >
    > 对于auto型局部变量，因为它们在运行时被分配在栈中，所以既不出现在.data节，也不出现在.bss节。

- .symtab:符号表(symbol table)。程序中定义的函数名和全局静态变量名都属于符号，与这些符号相关的信息保存在符号表中。每个可重定位目标文件都有一个.symtab节。

- .rel.text:.text节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时，.txt节中的代码被合并后，一些指令中引用的操作数地址信息或跳转目标指令位置信息等都可能要被修改。通常，调用外部函数或者引用全局变量的指令中的地址字段需要修改。

- .rel.data:.data节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时，.data节中的代码被合并后，一些全局变量的地址可能被修改。

- .dbug：调试用符号表，有些表项定义的局部变量和类型定义进行说明，有些表项对定义和引用的全局静态变量进行说明。只有使用带-g选项的gCc命令才会得到这张表。

- .line:C源程序中的行号和.text节中机器指令之间的映射。只有使用带-g选项的gcc命令才会得到这张表。

- .strtab:字符串表，包括.symtab节和.debug节中的符号以及节头表中的节名。字符串表就是以null结尾的字符串序列。

#### 节头表

节头表由若干个==表项==组成，每个表项描述相应的一个节的节名、在文件中的偏移、大小、访问属性、对齐方式等，目标文件中的每个节都有一个表项与之对应。除ELF头之外，节头表是ELF可重定位目标文件中最重要的一部分内容。以下是32位系统对应的数据结构，节头表中每个表项占40字节。

```c
typedef struct
{
    Elf32_Word        shname;   //节名字符串在.strtab中的偏移
    Elf32_Word        sh_type;   //节类型：无效/代码或数据/符号/字符串人…
    E1f32_Word        sh_flags;   //该节在存储空间中的访问属性
    Elf32_Addr        sh_addr;   //若可被加载，则对应虚拟地址
    Elf32_Off         sh_offset;   //在文件中的偏移，.bss节则无意义
    Elf32_Word        sh_size;	//节在文件中所占的长度
    Elf32_Word        sh_link;
    Elf32 Word        shinfo;
    Elf32_Word        sh_addralign;   //节的对齐要求
    Elf32_Word        sh_entsize;   //节中每个表项的长度
}E1f32_Shdr;
```

可以使用`readelf-S`命令对某个可重定位目标文件的节头表进行解析。例如，以下是通过“readelf-S test.o”对某test.o文件进行解析的结果。

```shell
There are 11 section headers,starting at offset 0x120:
Section Headers:
[Nr]Name			Off		Size	ES		F1g		Lk		Inf		Al
[0]					000000	000000	00				0		0		0
[1].text			000034	00005b	00		AX		0		0		4
[2].rel.text		000498	000028	08				9		1		4
[3].data			000090	00000c	00		WA		0		0		4
[4].bss				00009c	00000c	00		WA		0		0		4
[5].rodata			00009c	000004	00		A		0		0		1
[6].comment			0000a0	00002e	00				0		0		1	
[7].note.GNU-stack	0000ce	000000	00				0		0		1
[8].shstrtab		0000ce	000051	00				0		0		1	
[9].symtab			0002d8	000120	10				10		13		4
[10].strtab			0003f8	00009e	00				0		0		1
Key to Flags:
	W(write),A (alloc),X (execute),M (merge),S (strings)
	I(info),L (1ink order),G (group),x (unknown)
```

从上述解析结果可以看出，该test.o文件中共有11个节，节头表从120字节处开始。其中，.text、.data、.bss和.rodata节需要在存储器中分配空间，.text节是可执行的，.data和.bss两个节是可读写的，而.rodata节则是只读不可写的。

根据每个节在文件中的偏移地址和长度，可以画出可重定位目标文件test.o的结构，图中左边是对应节的偏移地址，右边是对应节的长度。例
如，.text节从文件的第0x34=52字节开始，共占0x5b=91字节。从节头表的解析结果看，.bss节和.rodata节的偏移地址都是0x00009c,占用区域重叠，因此可推断出.bss节在文件中不占用空间，但节头表中记录了.bss节的长度为0x0c=12,因而，需在主存中给.bss节分配12字节空间。

![test的节头表](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/11_11_35_43_202408111135645.png)



### 可执行目标文件格式

链接器将相互关联的可重定位目标文件中相同的代码和数据节（如.text节、.rodata节、.data节和.bss节)合并，以形成可执行目标文件中对应的节。因为相同的代码和数据节合并后，在可执行目标文件中各条指令之间、各个数据之间的相对位置就可以确定，因而所定义的函数（过程）和变量的起始位置就可以确定，也即每个符号的定义（即符号所在的首地址）即可确定，从而在符号的引用处可以根据确定的符号定义进行重定位。

ELF可执行目标文件由ELF头、程序头表、节头表以及夹在程序头表和节头表之间的各个不同的节组成。

![ELF可执行目标文件](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/11_11_43_36_202408111143785.png)





可执行文件格式与可重定位文件格式类似，例如，这两种格式中，ELF头的数据结构一样，.text节.rodata节和.data节中除了有些重定位地址不同以外，大部分都相同。与ELF可重定位目标文件格式相比，ELF可执行目标文件的不同点主要有：

1. ELF头中字段e_entry给出系统将控制权转移到的起始虚拟地址（入口点），即执行程序时第一条指令的地址。而在可重定位文件中，此字段为0。

2. 通常情况下，会带有一个.init节和一个.fini节，其中.init节定义了一个_init函数，用于可执行目标文件开始执行时的初始化工作，当程序开始运行时，系统会在进程进入主函数之前，先执行这个节中的指令代码。.fini节中包含进程终止时要执行的指令代码，当程序退出时，系统会执行这个节中的指令代码。

3. 少了.rel.text和.rel.data等重定位信息节。因为可执行目标文件中的指令和数据已被重定位，故可去掉用于重定位的节。

4. 多了一个==程序头表，也称段头表==(segment header table),它是一个结构数组。可执行目标文件中所有代码位置连续，所有只读数据位置连续，所有可读可写数据位置连续。

   1. 在可执行文件中，ELF头、程序头表、.init节、.fini节、.text节和.rodata节合起来可构成一个只读代码段(read-only code segment);

   2. .data节和.bss节合起来可构成一个可读写数据段(read/write data segment)。

   3. > [!NOTE]
      >
      > 显然，在可执行文件启动运行时，这两个段必须装入内存且需要为之分配存储空间，因而称为可装入段。

为了在可执行文件执行时能够在内存中访问到代码和数据，必须将可执行文件中这些连续的、具有相同访问属性的代码和数据段映射到存储空间（通常是虚拟地址空间)中。程序头表就用于描述这种映射关系，一个表项对应一个连续的存储段或特殊节。程序头表表项大小和表项数分别由ELF头中的字段e phentsize和e phnum指定。

32位系统的程序头表中每个表项具有以下数据结构：

```c
typedef struct
{
    Elf32_Word        p_type;
    E1f32_Off         p_offset;
    Elf32_Addr        p_vaddr;
    E1f32_Addr        ppaddr;
    E1f32_Word        p_filesz;
    Elf32_Word        p_memsz;
    Elf32_Word        p_flags;
    Elf32_Word        p_align;
}E1f32_Phdr;
```

- p_type描述存储段的类型或特殊节的类型。例如，是否为可装人段(PT_LOAD),是否是特殊的动态节(PT_DYNAMIC),是否是特殊的解释程序节(PT_INTERP)。
- p_offset指出本段的首字节在文件中的偏移地址。
- p_vaddr指出本段首字节的虚拟地址。
- p_paddr指出本段首字节的物理地址，因为物理地址由操作系统根据情况动态确定，所以该信息通常是无效的。
- p_filesz指出本段在文件中所占的字节数，可以为0。
- p_memsz指出本段在存储器中所占字节数，也可以为0。
- p_flags指出存取权限。
- p_align指出对齐方式，用一个模数表示，为2的正整数幂，通常模数与页面大小相关，若页面大小为4KB,则模数为$2^{12}$。

使用“readelf -l main”命令显示的可执行目标文件main的程序头表信息。

```c
Program Headers:
Type		offset		VirtAddr	PhysAddr	Filesiz MemSiz	F1g	Align
PHDR		0×000034	0x08048034	0×08048034	0x00100	0x00100	RE	0×4
INTERP		0×000134	0x08048134	0×08048134	0×00013	0x00013	R	0x1
			[Requesting program interpreter:/1ib/1d-linux.so.2]
LOAD		0x000000	0×08048000	0x08048000	0x004d4	0x004d4	RE	0x1000
LOAD		0x000f0c	0x08049fc	0x08049f0c	0x00108	0x00110	RW	0×1000
DYNAMIC		0x000f20	0x08049f20	0x08049f20	0x000d0	0x000d0	RW	0×4
NOTE		0x000148	0×08048148	0×08048148	0x00044	0×00044	R	0x4
GNU_STACK	0x000000	0×00000000	0x00000000	0×00000	0x00000	RW	0x4
GNURELRO	0x000f0c	0x08049f0c	0x08049f0c	0×000f4	0×000f4	R	0x1
```

程序头表中有8个表项，其中有两个是可装入段(Type=LOAD)对应的表项信息。

第一个可装入段对应可执行目标文件中第0x00000~0x0043字节的内容（包括ELF头、程序头表以及.init、.text和.rodata节等)，被映射到从虚拟地址0x8048000开始的长度为0x004d4字节的区域，按0x1000=22=4KB对齐，具有只读/执行权限(Flg=RE),它是一个只读代码段。

第二个可装入段对应可执行目标文件中第0x000f0c开始的长度为0x00108字节的内容（即.data节），被映射到从虚拟地址0x8049Oc开始的长度为0x00110字节的存储区域，在0x00110=272字节的存储区中，前0x00108=264字节用.data节的内容来初始化，而后面的272-264=8个字节对应.bss节，被初始化为0，该段按0x1000=4KB对齐，具有可读可写权限(Flg=RW),因此，它是一个可读写数据段。

从这个例子可以看出，.data节在可执行目标文件中占用了相应的磁盘空间，在存储器中也需要给它分配相同大小的空间；而.bss节在文件中==不占用磁盘空间==，但在存储器中==需要给它分配==相应大小的空间。

### 可执行文件的存储映像

对于特定的系统平台，可执行目标文件与虚拟地址空间之间的==存储器映像==（memory mapping)是由ABI规范定义的。

例如，对于IA-32+Linux系统，i386 System V ABI规范规定，

- 只读代码段总是映射到从虚拟地址为0x8048000开始的一段区域；

- 可读写数据段映射到只读代码段后面按4KB对齐的高地址上，其中.bss节所在存储区在运行时被初始化为0。

- 运行时堆(run-time heap)则在可读写数据段后面4KB对齐的高地址处，通过调用malloc库函数动态向高地址分配空间，

- 而运行时用户栈(run-time user stack)则是从用户空间的最大地址往低地址方向增长。

  - > [!NOTE]
    >
    > 堆区和栈区中间有一块空间保留给共享库目标代码，栈区以上的高地址区是操作系统内核的虚拟存储区。

![可执行文件在存储中的映像](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/11_15_26_17_202408111526160.png)

左边为可执行文件main中的存储信息，右边为虚拟地址空间中的存储信息。可以看出:

- 可执行文件最开始长度为0x004d4的可装入段映射到从虚拟地址0x8048000开始的只读代码段；
- 可执行文件中从0x00f0c到0x01013之间为.data节和.bss节（实际上都是.data节信息，而.bss节不占磁盘空间)，映射到从虚拟地址0x8049000开始的可读写数据段，其中.data节从0x8049f0c开始，共占0x00108=264字节，随后的8个字节空间分配给.bss节中定义的变量，初值为0。

当启动一个可执行目标文件执行时:

1. 首先会通过某种方式调出常驻内存的一个称为加载器(loader)的操作系统程序来进行处理。例如，任何UNX程序的加载执行都是通过调用execve系统调用函数来启动加载器进行的。
2. 加载器根据可执行目标文件中的程序头表信息，将可执行目标文件中相关节的内容与虚拟地址空间中的只读代码段和可读写数据段通过页表建立映射，
3. 然后启动可执行目标文件中的第一条指令执行。

根据ABI规范，特定的系统平台中的每个可执行目标文件都采用==统一==的存储器映像，映射到一个统一的虚拟地址空间，使得链接器在重定位时可以按照一个统一的虚拟存储空间来确定每个符号的地址，而不用关心其数据和代码将来存放在主存或磁盘的何处。因此，引入统一的虚拟地址空间简化了链接器的设计和实现。

同样，引入虚拟地址空间也简化了程序加载过程。因为统一的虚拟地址空间映像使得每个可执行目标文件的只读代码段都映射到从0x8048000开始的一块连续区域，而可读写数据段也映射到虚拟地址空间中的一块连续区域，因而加载器可以非常容易地对这些连续区域进行分页，并初始化相应页表项的内容。IA-32中页大小通常是4KB,因而，这里的可装入段都按$2^{12}$=4KB对齐。

加载时，只读代码段和可读写数据段对应的页表项都被初始化为“未缓存页”（即有效位为0)，并指向磁盘中可执行目标文件中适当的地方。因此，程序加载过程中，==实际上并没有真正从磁盘上加载代码和数据到主存==，而是仅仅创建了只读代码段和可读写数据段对应的页表项。只有在执行代码过程中发生了“缺页”异常时，才会真正从磁盘加载代码和数据到主存。

## 符号表和符号解析

### 符号和符号表

链接器在生成一个可执行目标文件时，必须完成符号解析，而要进行符号解析，则需要用到符号表。通常目标文件中都有一个符号表，表中包含了在程序模块中被定义的所有符号的相关信息。

对于某个C程序模块m来说，包含在符号表中的符号有以下三种不同类型：

- 在模块m中定义并被其他模块引用的*`全局符号`*(global symbol)。这类符号包括非静态的函数名和被定义为不带static属性的全局变量名。

- 由其他模块定义并被m引用的*`外部符号`*(external symbol),包括在其他模块定义的外部函数名和外部变量名。

- 在模块m中定义并在m中引用的*`本地符号`*(local symbol)。这类符号包括带static属性的函数名和全局变量名。这类在一个过程（函数）内部定义的带static属性的本地变量不在栈中管理，而是被分配在静态数据区，即编译器为它们在节.data或.bss中分配空间。如果在模块m内有两个函数使用了同名static本地变量，则需要为这两个变量都分配空间，并作为两个不同的符号记录到符号表中。

  例如，对于以下同一个模块中的两个函数func1和func2,假定它们都定义了static本地变量x且都被初始化，则编译器在该模块的.data节中同时为这两个变量分配空间，并在符号表中构建两个符号funcl.x和func2.x的关联信息。

  ```c
  int func1()
  {
      static int × = 0;
      return x;
  }
  
  int func2()
  {
      static int x=1;
      return x;
  }
  ```

> [!NOTE]
>
> 注意上述三类符号不包括分配在栈中的非静态局部变量(auto变量)，链接器不需要这类变量的信息，因而它们不包含在由节.symtab定义的符号表中。
>
> 例如，对于两个源程序文件main.c和swap.c来说，
>
> 在main.c中
>
> - 全局符号有buf和main
> - 外部符号有swap
>
> swap.c中
>
> - 全局符号有bufp0和swap
> - 外部符号有buf
>
> - 本地符号有bufp1。
> - 的temp是局部变量，是在运行时动态分配的，因此，它不是符号，不会被记录在符号表中。
>
> ---
>
> > *==main.c==*
> >
> > ```c
> > extern void swap(void);
> > int buf[2]={1,2};
> > int main(){
> >        swap();
> >        return 0;
> > }
> > ```
>
> > *==swap.c==*
> >
> > ```c
> > extern int buf[];
> > int *bufp0 &buf[0];
> > static int *bufp1;
> > void swap()
> > {
> >        int temp;
> >        bufpl &buf[1];
> >        temp *bufp0;
> >        *bufp0 *bufpl;
> >        *bufpl temp;
> > }
> > ```

ELF文件中包含的符号表中每个表项具有以下数据结构。

```c
typedef struct
{
    E1f32_Word        st_name;
    Elf32_Addr        st_value;
    Elf32_Word        st_size;
    unsigned char     st_info;
    unsigned char     st_other;
    E1f32_Half        st_shndx;
}
E1f32_Sym;
```

各字段的含义为：

- st_name给出符号在字符串表中的索引（字节偏移量），指向在字符串表(.strtab节）中的一个以null结尾的字符串，即符号。

- st_value给出符号的值，在可重定位目标文件中，是指符号所在位置相对于所在节起始位置的字节偏移量。
  - 例如，main.c的符号buf在.data节中，其偏移量为0。
  - 在可执行目标文件和共享目标文件中，st_value则是符号所在的虚拟地址。

- st_size给出符号所表示对象的字节个数。
  - 若符号是函数名，则是指函数所占字节个数；
  - 若符号是变量名，则是指变量所占字节个数。
  - 如果符号表示的内容没有大小或大小未知，则值为0。

- st_info指出符号的类型和绑定属性，从以下定义的宏可以看出，符号类型占低4位符号绑定属性占高4位。

  ```c
  #define ELF32_ST_BIND(info) 		((info)>>4)	//高四位
  #define ELF32_ST_TYPE(info)			((info)0xf)	//低四位
  #define ELF32_ST_INFO(bind,type)	(((bind)<<4) + ((type)&0xf))	//info的组成形式
  ```

  - 符号类型可以是未指定(==NOTYPE==)、变量(==OBJECT==)、函数(==FUNC==)、节(==SECTION==)等。当类型为“节”时，其表项主要用于重定位。

  - 绑定属性可以是本地(==LOCAL==)、全局(==GLOBAL==)、弱(==WEAK==)等。
    - 本地符号指在包含其定义的目标文件的外部是不可见的，名称相同的本地符号可存在于多个文件中而不会相互干扰。
    - 全局符号对于合并的所有目标文件都可见。
    - 弱符号与全局符号类似，但其定义具有较低的优先级。

- 字段st_other指出符号的可见性。通常在可重定位目标文件中指定可见性，它定义了当符号成为可执行目标文件或共享目标库的一部分后访问该符号的方式。

- 字段st_shndx用于指出符号所在节在节头表中的索引。有些符号属于三种特殊伪节(pseudo section)之一，伪节在节头表中没有相应的表项，无法表示其索引值，因而用以下特殊的索引值表示：

  - ABS表示该符号不会由于重定位而发生值的改变，即不应该被重定位；
  - UNDEF表示未定义符号，即在本模块引用而在其他模块定义的外部符号；
  - COMMON表示还未被分配位置的未初始化的变量，即.bss中的变量。对于COMMON类型的符号，其st_value字段给出的是对齐要求，而st_size给出的是最小长度。

可通过GNU READELF工具显示符号表。可使用命令`readelf -s main.o`查看main.o中的符号表。

```
Num:	Value	Size	Type	Bind	Ot	Ndx		Name
8:		0		8		OBJECT	GLOBAL	0	3		buf
9:		0		17		FUNC	GLOBAL	0	1		main
10:		0		0		NOTYPE	GLOBAL	0	UND		swap
```

从显示结果可看出：

- main模块的三个全局符号中，buf是变量(Type=OBJECT),它位于节头表中第三个表项（Ndx=3)对应的.data节中偏移量为0(Value=0)处，占8个字节(Size=8);
- main是函数(Type=FUNC),它位于节头表中第一个表项对应的.text节中偏移量为0处，占17个字节；
- sawp是未指定(NOTYPE)且无定义(UND)的符号，说明swap是在main中被引用的由外部模块定义的符号。

使用GNU READELF工具显示可重定位目标文件swap.o符号表中最后四个表项：

```
Num:	Value	Size	Type	Bind	Ot	Ndx	Name
8:		0		4		OBJECT	GLOBAL	0	3	bufp0
9:		0		0		NOTYPE	GLOBAL	0	UND	buf
10:		0		39		FUNC	GLOBAL	0	1	swap
11:		4		4		OBJECT	LOCAL	0	COM	bufpl
```

可以看出，swap模块的四个符号中，有三个全局符号和一个本地符号。其中：

- bufp0是全局变量，它位于节头表中第三个表项对应的.data节中偏移量为0处，占4个字节；
- buf是未指定的且无定义的全局符号，说明buf是在swap中被引用的由外部模块定义的符号；
- swap是函数，它位于节头表中第一个表项对应的.text节中偏移量为0处，占39个字节；
- bufp1是未分配位置且未初始化(Ndx=COM)的本地变量，按4字节边界对齐，至少占4个字节，当swap模块被链接时，bufpl将作为.bss节中的一个变量来分配空间。注意.swa即模块中的变量temp是函数内的局部变量，因而不在符号表中说明。

### 符号解析
符号解析的目的是将每个模块中==引用的符号==与某个目标模块中的==定义符号==建立关联。每个定义符号在代码段或数据段中都被分配了存储空间，因此，将引用符号与对应的定义符号建立关联后，就可以在重定位时将引用符号的地址重定位为相关联的定义符号的地址。

对于在一个模块中定义且在同一个模块中被引用的本地符号，链接器的符号解析会比较容易进行，因为编译器会检查每个模块中的本地符号是否具有唯一的定义，所以，只要找到第一个本地定义符号与之关联即可。对于跨模块的全局符号的解析，则比较困难。

编译器在对源程序编译时，会把每个全局符号输出到汇编代码文件中，每个全局符号或者是强符号或者是弱符号。汇编器把全局符号的强、弱特性隐含地编码在可重定位目标文件的符号表中，以供链接时符号解析所用。

#### 全局符号的强弱特性

强、弱符号的定义如下：函数名和已初始化的全局变量名是强符号，未初始化的全局变量名是弱符号。

例如，main、buf、swap和bufp0是强符号，bufp1为本地符号，而本地符号没有强弱之分，temp则是局部变量，不包含在符号表中。

链接器根据以下强符号和弱符号的处理规则来处理多重定义符号。

1. 规则1：强符号不能多次定义。也即强符号只能被定义一次，否则链接错误。
2. 规则2：若一个符号被说明为一次强符号定义和多次弱符号定义，则按强符号定义为准。
3. 规则3：若有多个弱符号定义，则任选其中一个。

#### 符号的解析过程

编译系统通常会提供一种将多个目标模块打包成一个单独的库文件的机制，这个库文件就是==静态库==(static library)。在构建可执行文件时只需指定库文件名，链接器会自动到库中寻找那些应用程序用到的目标模块，并且==只把用到的模块从库中拷贝出来==。

程序中的符号包括全局静态变量名和函数名：

- 它们在程序中可能出现在定义处，称为符号的定义；
- 也可能出现在引用处，称为符号的引用。

链接器按照所有可重定位目标文件和静态库文件出现在命令行中的顺序从左至右依次扫描它们，在此期间它要维护多个集合。其中

1. 集合`E`是指将被合并到一起组成可执行文件的所有目标文件集合；

2. 集合`U`是未解析符号的集合，未解析符号是指还未与对应定义符号关联的引用符号；

3. 集合`D`是指当前为止已被加人到`E`的所有目标文件中定义符号的集合。

> [!TIP]
>
> 所以说首先判断是不是要放入`E`中，然后再在`E`中找定义符号和未定义符号，定义符号放入`D`中，未定义符号放在`U`中

符号解析开始时，集合`E`、`U`、`D`中都是空的。然后按照以下过程进行符号解析：

1. 对命令行中的每一个输入文件`f`,链接器确定它是目标文件还是库文件，如果它是目标文件，就把`f`加入到`E`,根据`f`中未解析符号和定义符号分别对`U`、`D`集合进行修改，然后处理下一个输入文件。
2. 如果`f`是一个库文件，链接器会尝试把`U`中的所有未解析符号与`f`中各目标模块定义的符号进行匹配。如果某个目标模块`m`定义了一个`U`中的未解析符号`x`,那么就把`m`加入到`E`中，并把符号`x`从`U`移入`D`中。不断地对`f`中的所有目标模块重复这个过程直到`U`和`D`不再变化为止。那些未加入到`E`中的`f`里的目标模块就被简单地丢弃，链接器继续处理下一输入文件。
3. 如果处理过程中往`D`加入一个已存在的符号（出现双重定义符号），或者当扫描完所有输入文件时`U`非空，则链接器报错并停止动作。否则，链接器把`E`中的所有目标文件进行重定位后合并在一起，以生成可执行目标文件。

### 与静态库的链接

在类UNX系统中，静态库文件采用一种称为存档档案(archive)的特殊文件格式，使用==.a==后缀。例如，标准C函数库文件名为`libc.a`,其中包含一组广泛使用的标准I/O函数、字符串处理函数和整数处理函数，如`atoi`、`printf`、`scanf`、`strcpy`等，libc.a是默认的用于静态链接的库文件，无须在链接命令中显式指出。还有其他的函数库，例如浮点数运算函数库，文件名为`libm.a`,其中包含`sin`、cos和`sqrt`函数等。

用户也可以自定义一个静态库文件。以下通过一个简单例子来说明如何生成自己的静态库文件。假定有两个源文件myproc1.c和myproc22.c。

---

> *==myproc1.c==*
>
> ```c
> #include <stdio.h>
> void myfuncl()
> {
>     printf("%s","This is myfuncl from mylib!\n");
> }
> ```

> *==myproc2.c==*
>
> ```c
> #include <stdio.h>
> void myfunc2()
> {
>     printf("%s","This is myfunc2 from mylib!\n");
> }
> ```

可以使用==AR==工具生成静态库，在此之前需要用`gcc -c`命令将静态库中包含的目标模块先生成可重定位目标文件。以下两个命令可以生成静态库文件`mylib.a`,其中包含两个目标模块`myproc1.o`和`myproc2.o`。然后再将这两个可重定位目标文件组合成静态库文件。

```bash
gcc -c myprocl.c
gcc-c myproc2.c
ar rcs mylib.a myproc1.o myproc2.o
```

现假定有一个函数`main.c`调用库中的函数。

```c
void myfuncl(void);
int main()
{
    myfuncl();
    return 0;
}
```

为了生成可执行文件myproc,可以先将main.c编译并汇编为可重定位目标文件main.o,然后再将main.o和mylib.a以及标准C函数库libc.a进行链接。

```bash
gcc -c main.c
gcc -static -o myproc main.o ./mylib.a
```

命令中使用`-static`选项指示链接器应生成一个完全链接的可执行目标文件，即生成的可执行文件应能直接加载到存储器执行，而不需要在加载或运行时再动态链接其他目标模块。

符号解析过程如下。

1. 一开始`E`、`U`、`D`都是空集，链接器首先扫描到`main.o`,把它加入`E`,同时把其中未解析符号`myfun1`加入`U`,把定义符号`main`加入`D`,而且因为`main.o`的默认静态链接库是`libc.a`,所以`libc.a`被加人到当前输入文件列表的末尾。

2. 处理完`main.o`,接着扫描到`mylib.a`,因为这是个静态库文件，所以会拿当前`U`中的所有符号（本例中就一个符号`myfunc1`)与`mylib.a`中的所有目标模块（本例中有两个目标模块`myproc1.o`和`myproc2.o`)依次匹配，看是否有哪个模块定义了U中的符号，结果发现在`myproc1.o`中定义了`myfunc1`,于是`myprocl.o`被加入到`E`,`myfuncl`从`U`转移到`D`。在`myprocl.o`中发现还有未解析符号`printf`,因而将其加到`U`中。同样，`mylib.a`指定的默认标准库还是`libc.a`,它已经被加到当前输入文件列表的末尾，因此在此可以忽略它。不断地在静态库`mylib.a`的各模块上进行迭代以匹配`U`中的符号，直到`U`、`D`都不再变化。显然，此时`U`和`D`就不再发生变化，`U`中只有一个未解析符号`printf`,而`D`中有`main`和`myfuncl`两个定义符号。

3. 因为模块`myproc2.o`没有被加入`E`中，因而它被丢弃。

4. 接着扫描下一个输人文件，就是默认的库文件`libc.a`。链接器发现`libc.a`中的目标模块`printf.o`定义了符号`printf`,于是`printf`也从`U`移到`D`,同时`printf.o`被加入到`E`,并把它定义的所有符号都加入`D`,而所有未解析符号加入`U`。链接器还会把每个程序都要用到的一些初始化操作所在的目标模块（如`crt0.o`等）以及它们所引用的模块（如`malloc.o`、`free.o`等）自动加入到`E`中，并更新`U`和`D`以反映这个变化。事实上，标准库中各目标模块里的未解析符号都可以在标准库内其他模块中找到定义，因此当链接器处理完`libc.a`时，`U`一定是空的。此时，==链接器合并`E`中的目标模块并输出可执行目标文件==。

   ![可重定位目标文件和静态库的链接](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/18_15_12_35_202408181512826.png)

从上述描述的符号解析过程来看，符号解析结果与命令行中指定的输入文件的顺序相关。如果上述链接命令改为以下形式，则会发生链接错误。

```bash
gcc -static -o myproc ./mylib.a main.o
```

因为一开始先扫描到`mylib.a`,而`mylib.a`为静态库文件，所以，会根据其中是否存在`U`中的未解析符号对应的定义符号来确定是否将相应的目标模块加入`E`中，显然，开始时`U`是空的，因而在`mylib.a`中没有任何一个目标模块被加人`E`中，当扫描到`main.o`时，其引用符号`myfunc1`便不能被解析，所以被加入`U`中，这样，`U`中的`myfunc1`在后面将一直无法得到解析，最终因为`U`不空而导致链接器输出错误信息并终止。

> [!IMPORTANT]
>
> 关于静态库的链接顺序问题，通常的准则是将==静态库文件放在命令行文件列表的后面==，如有多个静态库文件，则根据这些静态库文件的目标模块中的符号是否有引用关系来确定顺序。
>
> - 若相互之间都没有引用关系，则说明它们之间相互独立，此时顺序可以任意，只要都放在后面即可；
> - 若相互之间有引用关系，则必须按照引用关系在命令行中排列静态库文件，使得对于每个静态库目标模块中的外部引用符号，在命令行中至少有一个包含其定义的静态库文件排在后面。
>
> 例如，假设`func.o`调用了静态库`libx.a`和`liby.a`中的函数，而`libx.a`又调用了`libz.a`中的函数，且`libx.a`和`liby.a`之间、`liby.a`和`libz.a`之间是相互独立的，则命令行中`libx.a`必须在`libz.a`之前，而`libx.a`和`iby.a`之间、`liby.a`和`libz.a`之间无须考虑顺序关系，即以下几个命令行都是可行的。
>
> ```bash
> gcc -static -o myfunc func.o libx.a liby.a libz.a
> gcc -static -o myfunc func.o liby.a libx.a libz.a
> gcc -static -o myfunc func.o libx.a libz.a liby.a
> ```
>
> 如果两个静态库的目标模块有相互引用关系，则在命令行中可以重复静态库文件名。
>
> 例如，假设`func.o`调用了静态库`libx.a`中的函数，而`libx.a`又调用了`liby.a`中的函数，同时，`liby.a`也调用了`libx.a`中的函数，则可用以下命令进行链接。
>
> ```bash
> gcc -static -o myfunc func.o libx.a liby.a libx.a
> ```

## 重定位过程

重定位的目的是在==符号解析的基础上将所有关联的目标模块==（即上述集合`E`中的模块）==合并==，并确定运行时每个定义符号在虚拟地址空间中的地址，在定义符号的引用处重定位引用的地址。

例如，在符号解析的例子中，编译`main.c`时，因为编译器还不知道函数`myprocl`的地址，所以编译器只是将一个“临时地址”放到可重定位目标文件`main.o`的`call`指令中，在链接阶段，这个“临时地址”将被修正为正确的引用地址，这个过程叫重定位。具体来说，重定位有以下两方面工作。

1. 节和定义符号的重定位。链接器将相互关联的所有可重定位文件中相同类型的节合并，生成一个同一类型的新节。例如，所有模块中的.data节合并为一个大的.data节，它就是生成的可执行目标文件中的.data节。然后链接器根据每个新节在虚拟地址空间中的起始位置以及新节中每个定义符号的位置，为新节中的每个定义符号确定存储地址。
2. 引用符号的重定位。链接器对合并后新代码节(.text)和新数据节(.data)中的引用符号进行重定位，使其指向对应的定义符号起始处。为了实现这一步工作，显然，链接器要知道目标文件中哪些引用符号需要重定位、所引用的是哪个定义符号等，这些称为重定位信息，放在重定位节(.rel.text和，.rel.data)中。

### 重定位信息

在可重定位目标文件的.rel.text节和.rel.data节中，存放着每个需重定位的符号的重定位信息。.rel.text节和.rel.data节采用的数据类型是结构数组，每个数组元素是一个表项，每个表项对应一个需重定位的符号，表项的数据结构如下：

```c
typedef struct
{
    Elf32_Addr	r_offset;
    Elf32_Word	r_info;
}E1f32_Re1;
```

- r_offset指出当前需重定位的位置相对于所在节起始位置的字节偏移量。若重定位的是变量的位置，则所在节为.data节；若重定位的是函数的位置，则所在节是.text节。
- r_info指出当前需重定位的符号所引用的符号在符号表中的索引值以及相应的重定位类型。从以下的宏定义中可以看出，符号索引(r_sym)是r_info的高24位，重定位类型（r_type)是其低8位。

```c
#define ELF32_R_SYM(info)	((info)>>8)
#define ELF32_R_TYPE(info)	((unsigned char)(info))
#define ELF32_R_INFO(sym,type)	(((sym)<<8)+(unsigned char)(type))
```

重定位类型与特定的处理器有关，具体由ABI规范定义。IA-32处理器的重定位类型有多种，最基本的是以下两种。

1. R_386_PC32:指明引用处采用PC相对寻址方式，即有效地址为PC内容加上重定位后的32位地址，PC的内容是下条指令地址。例如，调用指令call中的转移目标地址就采用相对寻址方式。
2. R_386_32:指明引用处采用绝对地址方式，即有效地址就是重定位后的32位地址。

重定位表的信息可以用命令`readelf -r`来显示，例如，可用命令`readelf-r main.o`来显示main.o中的重定位表项。为方便起见，以下叙述中把重定位后的32位地址简称为重定位值。

### 重定位过程

重定位过程需要对.text节和.data节中由相应的重定位节，.rel.text和.rel.data的重定位表项指出的每一处按顺序执行。

现假设main.o的.rel.text节中有一个表项：

1. r_offset=0x7
2. r_sym=10
3. r_type=R_386_PC32

该表项说明，需要在其.text节中偏移量为0x7的地方按照PC相对地址方式进行重定位，所引用的符号为main.o的符号表中第10个表项代表的符号
号。

现假设main.o的第十个表项为swap.o，swap.o的.rel.data中有一个表项：

1. r_offset=0x0
2. r_sym=9
3. r_type=R_386_32

该表项说明，需要在其.data节中偏移量为0的地方按绝对地址方式进行重定位，所引用的符号为swap.o符号表中第9个表项代表的符号。该符号为buf

## 动态链接

前面介绍了可重定位目标文件和可执行目标文件，还有一类目标文件是==共享目标文件==(shared object file),也称为共享库文件。它是一种特殊的可重定位目标文件，其中记录了相应的代码、数据、重定位和符号表信息，能在可执行目标文件装入或运行时被动态地装入内存并自动被链接，该过程称为动态链接(dynamic link),由一个称为动态链接器dynamic linker)的程序来完成。

> [!TIP]
>
> 类UNIX系统中共享库文件采用.so后缀，Windows系统中称其为动态链接库(Dynamic Link Library,简称DLL),采用.dl后缀。

### 动态链接的特性

静态链接方式因为库函数代码被合并、包含在可执行文件中，因而会造成磁盘空间和主存空间的极大浪费。

- 例如，静态库libc.a中的printf模块会在静态链接时被合并到每个引用printf的可执行文件中，其中的printf代码会各自占用不同的磁盘空间。通常磁盘上存放有数千个可执行文件，因而静态链接方式会造成磁盘空间的极大浪费；

- 在引用printf的应用程序同时在系统中运行时，这些程序中的printf代码也都会占用内存空间，对于并发运行几十个进程的系统来说，会造成极大的主存资源浪费。

==共享库==以动态链接的方式被正在加载或执行中的多个应用程序共享，因而，共享库的动态链接有两个方面的特点：

1. ==共享性==:指共享库中的代码段在内存只有一个副本，当应用程序在其代码中需要引用共享库中的符号时，在引用处通过某种方式确定指向共享库中对应定义符号的地址即可。
   1. 例如，对于动态共享库libc.so中的printf模块，内存中只有一个printf副本，所有应用程序都可以通过动态链接printf模块来使用它。

   2. 因为内存中只有一个副本，磁盘中也只有共享库中一份代码，所以能节省主存资源和磁盘空间。

2. ==动态性==：指共享库只在使用它的程序被加载或执行时才加载到内存，因而在共享库更新后并不需要重新对程序进行链接，每次加载或执行程序时所链接的共享库总是最新的。可以利用共享库的这个特性来实现软件分发或生成动态Web网页等。

动态链接有两种方式，一种是在程序==加载过程==中加载和链接共享库，另一种是在程序==执行过程==中加载和链接共享库。

### 程序加载时的动态链接

在类UNIX系统中，共享库文件使用.so后缀。例如，标准C函数库文件名为Iibc.so。用户也可以自定义一个动态共享库文件。例如，对于两个源程序文件myproc1.c和myproc2.c,可以使用以下GCC命令生成动态链接的共享库mylib.so。

```bash
gcc -shared -fPIC -o mylib.so myprocl.c myproc2.c
```

上述命令中-shared选项告诉链接器生成一个共享库目标文件；

-fPIC选项告诉编译器生成与位置无关的代码(Position Independent Code,PIC),使得共享库在被任何不同的程序引用时都不需要修改其代码。这保证了共享库代码的存储位置可以是不确定的，而且即使共享库代码的长度发生改变也不会影响调用它的程序。

假定有一个main.c程序，其中调用了mylib.so中的函数myfunc1。

```c
void myfunc1(void);
int main()
{
    myfunc1();
    return 0;
}
```

为了生成可执行目标文件myproc,可以先将main.c编译并汇编为可重定位目标文件main.o,然后再将main.o和mylib.so以及标准C函数共享库libc.so进行链接。以下命令可以完成上述功能：

```bash
gcc -o myproc main.c ./mylib.so
```

通过上述命令得到可执行目标文件myproc,这个命令与静态链接命令`gcc -static -o myproc main.c mylib.a`的执行过程不同。静态链接生成的可执行目标文件在加载后可以直接运行，因为所有外部函数都已包含在可执行目标文件中，而动态链接生成的可执行目标文件在加载执行过程中需要和共享库进行动态链接，否则不能运行。

这是因为在动态链接生成可执行目标文件时，其中对外部函数的引用地址是未知的。因此，在动态链接生成的可执行目标文件运行前，系统会首先将动态链接器以及所使用的共享库文件加载到内存。动态链接器和共享库文件的路径都包含在可执行目标文件中，其中，动态链接器由加载器加载，而共享库由动态链接器加载。

![加载时动态链接的过程](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/19_13_53_30_202408191353392.png)

动态链接加载过程被分成两步：

1. 首先，进行静态链接以生成部分链接的可执行目标文件myproc,该文件中仅包含共享库（包括指定的共享目标文件mylib.so和默认的标准共享库文件libe.so)中的符号表和重定位表信息，而共享库中的代码和数据并没有被合并到myproc中；
2. 然后，在加载myproc时，由加载器将控制权转移到指定的动态链接器，由动态链接器对共享目标文件libc.so、mylib.so和myproc中的相应模块内的代码和数据进行重定位并加载共享库，以生成最终的存储空间中完全链接的可执行目标，在完成重定位和加载共享库后，动态链接器把控制权转移到程序myproc。

> [!IMPORTANT]
>
> 在执行myproc的过程中，共享库中的代码和数据在存储空间的位置一直是固定的。
>
> 在上述过程中，有一个重要的问题是，如何在加载过程中将控制权从加载器转移到动态链接器？
>
> 实际上在可执行目标文件的程序头表中有一个Type=INTERP的段。因此，这个问题的解决可通过在可执行目标文件myproc中加入一个特殊的.interp节来实现。当加载myproc时，加载器会发现在myproc的程序头表中包含了.interp节构成的段，其p_type字段取值为PT_INTERP,该节中包含了动态链接器的路径名，而动态链接器本身也是一个共享目标，在Linux系统中为ld-linux.so文件，.interp节中有这个文件的路径信息，因而
> 可以由加载器根据指定的路径来加载并启动动态链接器运行。动态链接器完成相应的重定位工作后再把控制权交给myproc,启动其第一条指令执行。

### 程序运行时的动态链接

在一些类UNⅨ系统中，提供了一个动态链接器接口，其中定义了相应的几个函数，如dlopen、dlsym、dlerror、dlclose等，其头文件为dlfen.h。

以下给出一个例子，用以说明如何在应用程序中使用动态链接器接口函数对共享库进行动态链接。图4.23给出了一个运行时进行动态链接的应用程序示例main.c。对于由图4.15所示的两个源程序文件myproc1.c和myproc2.c生成的共享库mylib.so,在main.c中调用了共享库mylib.so中的函数myfunc1。



```c
#include <stdio.h>
#include <dlfcn.h>
int main()
{
    void *handle;
    void (*myfuncl)();
    char *error;

    /*动态装入包含函数myfuncl()的共享库文件*/
    handle = dlopen("./mylib.so",RTLD_LAZY);
    if (!handle){
        fprintf(stderr,"%s\n",dlerror());
        ex1t(1);
    }

    /*获得一个指向函数nyfuncl()的指针nyfunc1*/
    myfuncl = dlsym(handle,"myfunc1");
    if ((error = dlerror()) != NULL){
        fprintf(stderr,"%s\n",error);
        ex1t(1);
    }

    /*现在可以像调用其他函数一样调用函数myfunc1()*/
    myfunc1()；

        /*关闭（卸载）共享库文件*/
        if (dlclose(handle)<0){
            fprintf(stderr,"%s\n",dlerror());
            exit(1);
        }
    return 0;
}
```

要编译该程序并生成可执行文件myproc,通常用以下GCC命令：

```
gcc -rdynamic -o myproc main.c -1dl
```

- 选项-rdynamic指示链接器在链接时使用共享库中的函数，
- 选项-ldl说明采用动态链接器接口中的dlopen、dsym等函数进行运行时的动态链接。

一个应用程序如果要在运行时动态链接一个共享库并引用库中的函数或变量，则必须经过以下几个步骤。

1. 首先，通过dlopen函数加载和链接共享库，第10行的含义是启动动态链接器来加载并链接当前目录中的共享库文件mylib.so,这里dlopen函数的第二个参数为RTLD_LAZY,用来指示链接器对共享库中外部符号的引用不在加载时进行重定位，而是延迟到第一次函数调用时进行重定位，称为延迟绑定(lazy binding)技术。若dlopen函数出错，则返回值为NULL;否则返回指向共享库文件句柄的指针。
2. 在dlopen函数正常返回的情况下，通过dlsym函数获取共享库中所需函数。如第17行所示。第17行的含义是指示动态链接器返回指定共享库mylib.so中指定符号myfunc1的地址。若指定共享库中不存在指定的符号，则返回NULL。dlsym函数的第一个参数是指定共享库的文件句柄，第二个参数用来标识指定符号的字符串，通常是后面将要使用的函数的函数名。
3. 在dlsym函数正常返回的情况下，就可以使用共享库中的函数，如第24行所示。函数对应代码的首地址由dlsym函数返回。
4. 在使用完程序所需的所有共享库内函数或变量后，使用dlclose函数卸载这个共享库。如第27行所示。若卸载成功，返回为0，否则为-1。若调用dlopen、dlsym和dlclose时发生出错，则出错信息可通过调用dlerror函数获得。

### 位置无关代码

共享库代码在磁盘上和内存中都只有一个备份，在磁盘上就是一个共享库文件，如类UNX系统中的`.so`文件或Windows系统中的`.dll`文件。为了让一份共享库代码可以和不同的应用程序进行链接，共享库代码必须与地址无关，也就是说，在生成共享库代码时，要保证将来不管共享库代码加载到哪个位置都能够正确执行，也即共享库代码的加载位置可以是不确定的，而且共享库代码的长度发生变化也不影响调用它的程序。满足上述这种特征的代码称为==位置无关代码==(Position-Independent Code,.PIC)。

显然，共享库文件必须是位置无关代码，因而在生成共享库文件时，须使用GCC选项`-PIC`来生成位置无关代码。

符号之间的所有引用包含以下四种情况：

1. 模块内过程调用和跳转；
2. 模块内数据引用；
3. 模块间数据引用；
4. 模块间过程调用和跳转。

对于前两种情况，因为是在模块内进行函数（过程)和数据的引用，因而采用PC相对偏移寻址方式就可以方便地实现位置无关代码。

对于后面两种情况，由于涉及模块之间的访问，所以无法通过PC相对偏移寻址来生成位置无关代码，需要有专门的实现机制。

#### 模块内过程调用和跳转

函数foo调用了模块内的一个函数bar,因此属于模块内的过程调用。因为foo和bar在同一个模块中，因而这两个函数的代码都在同一个.text节中，相对位置固定，只要在实现过程调用的call指令中采用PC相对偏移寻址方式，即可生成位置无关代码。显然，不管so文件中的代码加载到哪里，call指令中的偏移量都不变。

```c
static int a;
static int b;
extern void ext();

void bar()
{
    a=1;
    b=2;
}

void foo()
{
    bar();
    ext()；
}
```

编辑为机器指令的代码为

```assembly
0000344<bar>:	
0000344:	55				push1	%ebp
0000345:	89e5			movl	%esp,%ebp
......
0000362:	c3				ret	
0000363:	90				nop
0000364 <fo0>:
0000364:	55				push1 	%ebp
......
0000374:	e8 db ff ff ff	ca11	0000344<bar>
0000379:
......
```

编译器在生成call指令时，只要根据被引用函数bar的起始位置和call指令下条指令的起始位置之间的位移量就可算出偏移地址为0x0000344-0x0000379=0xffff ffcb=-0x35。同样，模块内的跳转也可用jmp即指令通过PC相对寻址方式来生成位置无关代码。

#### 模块内数据引用

函数bar引用了模块内的静态变量a和b,因此属于模块内的数据访问。因为在同一个模块内数据段总是紧跟在代码段后面，因而任何引用某符号的指令与数据段起始处之间的位移量，以及本地局部符号在数据段内的位移量都是确定的。编译器可以利用这些特性生成位置无关代码。

以下是源程序经编译后得到的部分机器级代码示例，主要给出了赋值语句`a=1;`的编译结果。可以看出，为了生成位置无关代码，编译器对语句`a=1;`生成了多条指令，这里假设call指令的下条指令到数据段起始位置之间的位移量为0x118c,数据段起始位置到变量a之间的位移量为0x28。

```assembly
0000344	<bar>:
0000344:	55				push1	%ebp
0000345:	89e5			mov1	%esp,%ebp
0000347:	e850000000		call	39c <get_pc>
000034c:	81c18c110000	addl	$0x118c,%ecx
0000352:	c78128000000	movl	$0x1,0x28(%ecX)
......
0000362:	c3				ret


000039c	<get_pc>:
000039c:	8b0c24			mov1	(esp),%ecx
000039f:	c3				ret
```

上述机器级代码0000347处开始的三条指令对应函数bar中语句`a=1；`。首先，通过指令“call 39c<_get-pc>”将下条指令的地址保存在栈顶位置，然后再通过000039c处的“movl (%esp),%ecx”指令将当前栈顶位置送到ECX中，这样，不管这段共享代码加载到哪里，都会将引用a的指令的地址记录在ECX中。下一条指令再将该地址值加上0x118c,得到数据段首地址送ECX,然后再通过“基址加偏移量”的方式得到a的地址，从而实现对静态变量a的引用。通常，生成位置无关代码会带来一些额外的开销，可以看出，模块内数据访问情况下的位置无关代码多用了4条指令。在x86-64中，因为允许将P寄存器作为基址寄存器，所以使用一条指令即可实现模块内数据引用，从而可以减少额外开销。

#### 模块间数据引用

在以下函数bar中的赋值语句“b=2;”引用了模块外的一个外部变量b,因此属于模块间的数据访问。因为变量b是外部符号，所以在对赋值语句“b=2;”进行编译转换时，无法事先计算出变量b到引用b的指令之间的相对距离。

```c
static int a;
extern int b;
extern void ext();
void bar(){
    a=1;
    b=2;   
}
```

不过，因为任何引用符号的指令与本模块数据段起始处之间的位移量是确定的，因而，可以在数据段开始处设置一个表，只要在程序执行时外部变量b的地址已记录在这个表中，那么引用b的指令就可以通过访问这个表中的地址来实现对b的引用。以下是源程序经编译后得到的部分机器级代码示例。此例中，假设引用b的指令序列开始处（即popl指令起始处)到变量b所在的表项之间的位移量为0x1180。

```assembly
0000344<bar>:
0000344:	55			push1	%ebp
......
0000357:	e800000000	call	000035c
000035c:	5b			popl	%ebx
000035d:				addl	$0x1180,%ebx
......					mov1	(%ebx),%eax
......					movl	$2,(%eax)
```

上述代码段中，通过0000357处开始的“call 000035c”和“popl %ebx”指令，将赋值语句“b=2;”对应的指令序列首地址送EBX;通过加上位移量0x1180,得到外部变量b的地址所存放的位置值送EBX;然后根据EBX访问变量b所对应的表项，得到变量b的地址送EAX;最后通过EAX引用变量b。这个设置在数据段起始处的用于存放全局变量地址的表称为==全局偏移量表==(Global OffsetTble,GOT),其中每个表项对应一个全局变量，用于在动态链接时记录对应的全局变量的地址。

ABI规范定义了GOT的具体结构与相应的处理过程。编译器为GOT中每一个表项生成一个重定位项，指示动态链接器在加载并进行动态链接时必须对这些GOT表项中的内容进行重定位，也即在动态链接时需要对这些表项绑定一个符号定义，并填人所引用的符号的地址。例如，对于上述例子，在加载并进行动态链接时，动态链接器应将符号b在其他模块中定义的地址，填人到本模块GOT中变量b对应的表项中。这样，在指令执行时，就可以从GOT中取到变量b在外部模块中的地址了。同样，模块间数据访问时的位置无关代码也有缺陷，除了多用4条指令外，还增加了用于实现GOT的空间和时间，并多使用了一个被调用者保存寄存器EBX。

#### 模块间过程调用和跳转

以下是一个源程序部分代码，其中，函数foo调用了一个外部函数ext,因此，属于模块间过程调用。与模块间数据引用一样，模块间过程调用也可以通过在数据段起始处增加一个全局偏移量表GOT来解决位置无关代码的生成问题，只要在GOT中增加外部函数对应的表项即可。

```c
static int a;
extern int b;
extern void ext();
void foo()
{
    bar();
    ext();
}
```

对于以上的源程序，可以在GOT中设置一个与外部函数ext对应的表项。以下是该源程序经编译后得到的部分机器级代码示例。此例中，假设调用ext函数的指令序列起始处（即popl指令起始处)与GOT中ext对应表项之间的位移量为0x1204。

```assembly
000050c<fo0>:
000050c:	55			pushl	%ebp
......
0000557:	e800000000	call	000055c
000055c:	5b			popl	%ebx
000055d:				addl	$0x1204,%ebx
......
......					call	*(%ebx)】
```

上述代码中，从0000557开始的三条指令用于将数据段起始处的GOT中ext对应表项的地址送EBX,000055d处随后的`call*(%ebx)`指令将EBX所指向的GOT表项中的地址作为调用函数的目标地址，转到ext函数去执行。这里，*(%ebx)为间接地址，即通过“R[eip]←M[R[ebx]]”实现过程调用。与模块间数据引用一样，编译器也要为GOT中ext对应表项生成一个重定位项，GOT中的ext函数地址也是在加载时通过动态链接进行重定位而得到的。

从上述代码可以看出，每次进行模块间过程调用都要额外执行三条指令。如果存在大量这种模块间过程调用的话，就会额外执行大量指令。为此，GCC编译器采用了一种延迟绑定技术，以减少额外指令条数。

*`延迟绑定`(lazy binding)*技术的基本思想是：对于模块间过程的引用不在加载时进行重定位，而是延迟到第一次函数调用时进行重定位。延迟绑定技术除了需要使用GOT外，还需要使用==过程链接表==(Procedure Linkage Table,PLT)。其中，GOT是.data节（包含在数据段中）的一部分，而PLT是.text节（包含在代码段中）的一部分。

![可执行文件中的PLT和GOT](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/27_10_52_38_202408271052892.png)

图中对应可执行文件foo中的PLT和GOT。采用延迟绑定技术时，GOT中开始三项总是固定的，含义如下：

- GOT[0]为.dynamic节首址，该节中包含动态链接器所需要的基本信息，如符号表位置、重定位表位置等；
- GOT[1]为动态链接器的标识信息；
- GOT[2]为动态链接器延迟绑定代码的入口地址。

此外，所有被调用的外部函数在GOT中都有对应的表项，例如，上图的GOT[3]就是外部函数ext对应表项。

PLT中每个表项占16字节，它是.text节的一部分，每个表项中实际上包含的是3条指令。除PLT[0]外，其余各项各自对应一个共享库函数，例如，以下的PLT[1]对应ext函数。

```assembly
PLT[O]
0804833c:	ff3588950408	pushl	0x8049588
 8048342:	ff258c950408	jmp		0x804958c
 8048348:	00000000	
PLT[1]	<ext>
0804834c:	ff2590950408	jmp		*0x8049590
8048352:	6800000000		pushl	$0x0
8048357:	e9 eo ff ff ff	jmp		804833c
```

编译器在处理外部过程ext的调用时，首先在GOT和PLT中填人以上相应信息，然后生成以下机器级代码：

```assembly
804845b:	e8ecfeffff	ca11	804834c	<ext>
```

启动对应的可执行文件运行后，当第一次执行到上述这条call指令时，将根据目标地址0x804834c,转到PLT[1]处执行。第一条间接跳转指令的执行过程是，先根据地址0x8049590找到ext对应的表项GOT[3],然后根据其中的内容再跳转到0x08048352处执行。此处是一条pushl指令，用于将ext对应的ID压栈，然后执行jmp指令，跳转到0x804833c处的PLT[0]处执行。

PLT[0]中第一条指令将GOT[1]的地址0x8049588压栈，然后通过间接跳转指令，转到GOT[2]指出的动态链接器延时绑定代码处执行。这样，动态链接器延时绑定代码将根据GOT[1]中记录的动态链接器标识信息和ext对应的ID信息，对外部过程ext进行重定位，即在GOT[3]中填入真正的外部过程ext的地址，并控制程序转ext过程执行。

这样，以后再调用外部过程ext时，每次都只要执行“jmp*0x8049590”就可以直接跳转到ext执行了，仅仅多执行了一条jmp指令，而不是多执行三条指令。可以看出，延迟绑定技术的开销主要在第一次过程调用，需要额外执行多条指令，而以后每次都只是多执行一条指令，这对于同一个外部过程被多次调用的情况非常有益。

# 层次结构存储系统

## 存储器概述

### 存储器的分类

1. 按存储元件分类：存储元件必须具有截然不同且相对稳定的两个物理状态，才能被用来表示二进制代码0和1。

   - *`半导体`存储器*：使用半导体器件构成
   - *`磁性表面`存储器*：使用磁性材料作为存储器，如磁盘存储和磁带存储
   - *`光盘`存储器*：使用光介质存储

2. 按存取方式分类

   - *`随机存取`存储器*：随机存取存储器(Random Access Memory,简称==RAM==)的特点是按地址访问存储单元，因为每个地址译码时间相同，所以，在不考虑芯片内部缓冲的前提下，每个单元的访问时间是一个常数，与地址无关。不过，现在的DRAM芯片内都具有行缓冲，因而有些数据可能因为已在行缓冲中而缩短了访问时间。随机存取存储器的存储介质是半导体存储器件。
   - *`顺序存取`存储器*：顺序存取存储器(Sequential Access Memory,简称==SAM==)的特点是信息按顺序存放和读出，其存取时间取决于信息存放位置，以记录块为单位编址。磁带存储器就是一种顺序存取存储器，其存储容量大，但存取速度慢。
   - *`直接存取`存储器*:直接存取存储器（Direct Access Memory，简称==DAM==）的存取方式兼有随机访问和顺序访问的特点。首先直接定位到需读写信息所在区域的开始处，然后按顺序方式存取，磁盘存储器就是如此。
   - *`相联`存储器*:上述三类存储器RAM、SAM和DAM都是按所需信息的地址来访问，但有些情况下可能不知道所访问信息的地址，只知道要访问信息的内容特征，此时，只能按内容检索到存储位置进行读写。这种存储器称为按内容访问存储器Content Addressed Memory，简称==CAM==）或相联存储器（Associative Memory，简称AM）。

3. 按信息的可更改性分类:按信息可更改性分读写存储器和只读存储器（Read Only Memory，简称==ROM==）。

   - *`读写`存储器*中的信息可以读出和写人，RAM芯片是一种读写存储器；

   - *`只读`存储器*ROM芯片中的信息一旦确定，通常在联机情况下只能读不能写，但在某些情况下也可重新写入。

   - > [!IMPORTANT]
     >
     > RAM芯片和ROM芯片都采用随机存取方式进行信息的访问。

4. 按断电后信息的可保存性分类:
   - *`非易失性`存储器*（Nonvolatile Memory）,非易失性存储器也称不挥发性存储器，其信息可一直保留，不需电源维持，例如，ROM、磁表面存储器、光盘存储器等都是非易失性存储器；
   - *`易失性`存储器*（Volatile Memory）,易失性存储器也称挥发性存储器，在电源关闭时信息自动丢失，例如，RAM、cache等都是易失性存储器。
5. 按功能分类
   - *`高速缓冲`存储器*:高速缓冲存储器(==cache==)简称高速缓存，位于主存和CPU之间，目前主要由静态RAM芯片组成，其存取速度接近CPU的工作速度，用来存放当前CPU经常使用到的指令和数据。
   - *`主`存储器*:指令直接面向的存储器是主存储器，简称主存。CPU执行指令时给出的存储地址最终必须转换为主存地址，若不采用虚拟存储管理，则CPU直接给出主存地址。主存是存储器分层结构中的核心存储器，用来存放系统中启动运行的程序及其数据，主存目前一般用MOS管半导体存储器构成。
   - *`辅助`存储器*:把系统运行时直接和主存交换信息的存储器称为辅助存储器，简称辅存。磁盘存储器比磁带和光盘存储器速度快，因此，目前大多用磁盘存储器作为辅存，辅存的内容需要调入主存后才能被CPU访问。
   - *`海量后备`存储器*:磁带存储器和光盘存储器的容量大、速度慢，主要用于信息的备份和脱机存档，因此被用作海量后备存储器。辅存和海量后备存储器统称为外部存储器，简称外存。

一般的计算机都会使用以下的存储层次结构

![存储器层次化体系结构](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/27_11_56_52_202408271156042.png)

### 主存储器的组成和基本操作

下图是主存储器(Main Memory,简称MM)的基本框图。其中由一个个存储0或1的记忆单元(cell)构成的存储阵列是存储器的核心部分。这种记忆单元也称为==存储元==、==位元==，它是具有两种稳态的能表示二进制0和1的物理器件。

==存储阵列==(bank)也称为存储体、存储矩阵。为了存取存储体中的信息，必须对存储单元编号，所编号码就是==地址==。编址单位(addressing unit)是指具有相同地址的那些位元构成的一个单位，可以是一个字节或一个字。

对各存储单元进行编号的方式称为==编址方式==(addressing mode),可以按字节编址，也可以按字编址。现在大多数通用计算机都采用字节编址方式，此时，存储体内一个地址中有一个字节。也有许多专用于科学计算的大型计算机采用64位编址，这是因为科学计算中数据大多是64位浮点数。

![主存储器的基本框图](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/08/27_11_33_30_202408271133762.png)

如上图所示，指令执行过程中需要访问主存时：

1. CPU首先把欲访问的主存单元的地址送到主存地址寄存器(Memory Address Register,简称MAR)中，然后通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码后选中相应单元。
2. 同时，CPU将读/写控制信号通过控制线送到主存的读写控制电路。
   1. 如果是写操作，CPU同时将要写的信息送主存数据寄存器(Memory Data Register,简称MDR)中，在读写控制电路的控制下，经数据线将信息写入选中的单元；
   2. 如果是读操作，则主存读出选中单元的内容送数据线，然后送到MDR中。数据线的宽度与MDR的宽度相同，地址线的宽度与MAR的宽度相同。图中采用64位数据线，因此，在字节编址方式下，每次最多可以存取8个字节的内容。地址线的位数决定了主存地址空间的最大可寻址范围，例如，36位地址的最大可寻址范围为0~26-1。注意：在计算机中所有地址的编号总是从0开始。

## 主存与CPU的连接及其读写操作

### 主存芯片技术

动态RAM主要用作主存，目前主存常用的是基于SDRAM(Synchronous DRAM)芯片技术的内存条，包括DDR SDRAM、DDR2 SDRAM和DDR3 SDRAM等。SDRAM芯片与当年Intel推出的芯片组中北桥芯片的前端总线同步运行，因此，称为同步DRAM。

#### DRAM芯片技术

目前，动态存储芯片大多采用双译码结构。地址译码器分为X和Y方向两个译码器。

![DRAM存储芯片](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/09/23_12_0_7_202409231200159.png)

其中的存储阵列有4096个单元，需要12根地址线，用A~11~ ~ A ~0~表示。

- A~11~ ~ A~6~送至X译码器，有64条译码输出线，各选择一行单元；
- A~5~ ~ A~0~送至Y译码器，它也有64条译码输出线，分别控制一列单元的位线控制门。

>  假如输入的12位地址为A~11~A~10~…A~0~=000001_000000,则X译码器的第2根译码输出线(x~1~)为高电平，与它相连的64个存储单元的字选择W线为高电平。Y译码器的第1根译码输出线(y~0~)为高电平，打开第一列的位线控制门。在X、Y译码的联合作用下，存储阵列中(1,0)单元被选中。

在选中的行和列交叉点上的单元只有一位，因此，采用二维双译码结构的存储器芯片被称为`位片式芯片`。有些芯片的存储阵列采用三维结构，用多个位平面构成存储阵列，不同位平面在同一行、列交叉点上的多位构成一个存储字，被同时读出或写入。

在双译码结构中，一条X方向的选择线要控制在其上的各个存储单元的字选择线，所以负载较大，因此需要在译码器输出后加驱动电路。此外，I/O控制电路则用以控制被选中的单元的读出或写入，具有放大信息的作用。以下是4M×4位的芯片框图：

![DRAM芯片](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/09/23_13_49_14_202409231349817.png)

DRAM芯片容量较大，因而地址位数较多。为了减少芯片的地址引脚数，从而减小体积，大多采用地址引脚复用技术。行地址和列地址通过相同的引脚分先后两次输入，这样地址引脚数可减少一半。

子图a给出了芯片的引脚：

1. 共有11根地址引脚线A~0~ ~ A~10~,在行地址选通信号RAS和列地址选通信号CS(低电平有效)的控制下，用于分时传送行、列地址；
2. 有4根数据引脚线D~1~ ~ D~4~ ,因此，每个芯片同时读出4位数据；
3. WE为读写控制引脚，低电平时为写操作；
4. OE为输出使能驱动引脚，低电平有效，高电平时断开输出。

子图b给出了芯片内部的逻辑结构图，芯片存储阵列采用三维结构，芯片容量为2048×2048×4位（$2048=2^{11}$,11条地址总线）。因此，行地址和列地址各是11位，有4个位平面，在每个行、列交叉处的4个位平面数据同时进行读写。行地址缓冲器和刷新计数器通过一个多路选择器MUX,将选择的行地址输出到行译码器，刷新计数器的位数也是11位，一次刷新相当于对一行数据进行一次读操作，通过对这一行数据读后再生进行刷新。

#### 基本SDRAM技术

SDRAM的工作方式与传统的DRAM有很大不同:

- 传统DRAM与CPU之间采用==异步方式==交换数据，CPU发出地址和控制信号后，经过一段延迟时间，数据才读出或写入。在这段时间里，CPU不断采样DRAM的完成信号，在没有完成之前，CPU插人等待状态而不能做其他工作。
- 而SDRAM芯片则不同，其读写受外部系统时钟（即前端总线时钟CLK)控制，因此与CPU之间采用同步方式交换数据。它将CPU或其他主设备发出的地址和控制信息锁存起来，经过确定的几个时钟周期后给出响应。因此，主设备在这段时间内，可以安全地进行其他操作。

SDRAM的每一步操作都在外部系统时钟CLK的控制下进行，支持突发传输(bust)方式。只要在第一次存取时给出首地址，以后按地址顺序读写即可，而不再需要地址建立时间和行、列预充电时间，就能连续快速地从行缓冲器中输出一连串数据。内部的工作方式寄存器(也称模式寄存器)可用来设置传送数据的长度以及从收到读命令（与CAS信号同时发出）到开始传送数据的延迟时间等，前者称为突发长度(Burst Length,简称BL),后者称为CAS潜伏期(CAS Latency,简称CL)。根据所设定的BL和CL,CPU可以确定何时开始从总线上取数以及连续取多少个数据。在开始的第一个数据读出后，同一行的所有数据都被送到行缓冲器中，因此，以后每个时钟可从SDRAM读取一个数据，并在下一个时钟内通过总线传送到CPU。

基于SDRAM技术的芯片的工作过程大致如下：

1. 在CLK时钟上升沿片选信号(CS)和行地址选通信号(RAS)有效。
2. 经过一段延时t~RCD~(RAS to CAS delay),列选通信号CAS有效，并同时发出读或写命令，此时，行、列地址被确定，已选中具体的存储单元。
3. 对于读操作，再经过一个CAS潜伏期后，输出数据开始有效，其后的每个时钟都有一个或多个数据连续从总线上传出，直到完成突发长度BL指定的所有数据的传送。对于写操作，则没有CL延时而直接开始写人。

由于只有读操作才有CL,所以CL又被称为读取潜伏期(Read Latency,简称RL)。t~RCD~和CL都是以时钟周期T~CK~为单位，例如，对于PC100 SDRAM来说，当T~CK~为10ns,CL为2时，则CAS潜伏期时延为20ns。BL可用的选项为1、2、4、8等，当BL为1时，则是非突发传输方式。

#### DDR SDRAM芯片技术

DDR(Double Data Rate)SDRAM是对标准SDRAM的改进设计，通过芯片内部I/O缓冲(I/O Buffer)中数据的两位预取功能，并利用存储器总线上时钟信号的上升沿与下降沿进行两次传送，以实现一个时钟内传送两次数据的功能。例如，采用DDR SDRAM技术的PC3200(DDR400)存储芯片内CLK时钟的频率为200MHz,意味着存储器总线上的时钟频率也为200MHz,利用存储芯片内部的两位预取技术，使得一个时钟内有两个数据被取到I/O缓冲中。
因为存储器总线在每个时钟内可以传送两次数据，而存储器总线中的数据线位宽为64，即每次传送64位，因而存储器总线上数据的最大传输率（即带宽）为$200MHz×2×64b/8(b/B)=3.2GB/s$。

#### DDR2 SDRAM

DDR2 SDRAM内存条采用与DDR类似的技术，利用芯片内部的I/O缓冲可以进行4位预取。例如，采用DDR2 SDRAM技术的PC2-3200(DDR2-400)存储芯片内部CLK时钟的频率为200MHz,意味着存储器总线上的时钟频率应为400MHz,利用存储芯片内部的4位预取技率应为400MHz,利用存储芯片内部的4位预取技术，使得一个时钟内有4个数据被取到/0缓冲中，存储器总线在每个时钟内传送两次数据，若每次传送64位，则存储器总线的最大数据传输率（即带宽）为$200MHz×4×64b/8(b/B)=400MHz×2×64b/8(b/B)=6.4GB/s$。

![DDR2 SDRAM](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/09/23_14_53_38_202409231453533.png)

#### DDR3 SDRAM芯片技术

DDR3 SDRAM芯片内部I/O缓冲可以进行8位预取。如果存储芯片内部CLK时钟的频率为200MHz,意味着存储器总线上的时钟频率应为800MHz,存储器总线在每个时钟内可传送两次数据，若每次传送64位，则对应存储器总线的最大数据传输率（即带宽）为$200MHz×8×64b/8(b/B)=800MHz×2×64b/8(b/B)=12.8GB/s$。

### 主存与CPU的连接及读写

CPU通过其芯片内的总线接口部件（即总线控制逻辑)与处理器总线相连，然后再通过总线之间的I/O桥接器、存储器总线连接到主存。

总线是连接其上的各部件共享的传输介质，通常的构成为：

1. 控制线
2. 数据线
3. 地址线。

计算机中各部件之间通过总线相连，例如，CPU通过处理器总线和存储器总线与主存相连。在CPU和主存之间交换信息时，CPU通过总线接口部件把地址信息和总线控制信息分别送到地址线和控制线，CPU和主存之间交换的数据则通过数据线传输。

![主存与CPU之间的连接](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/09/24_17_12_58_202409241712125.png)

受集成度和功耗等因素的限制，单个芯片的容量不可能很大，所以往往通过存储器芯片扩展技术，将多个芯片做在一个内存模块（即内存条）上，然后由多个内存模块以及主板或扩充板上的RAM芯片和ROM芯片组成一台计算机所需的主存空间，再通过总线、桥接器等和CPU相连。下图中的a是内存条和内存条插槽(slot)示意图，b是存储控制器(memory controller)、存储器总线、内存条和DRAM芯片之间的连接关系示意图。存储控制器可以包含在上图中的I/O桥接器中。

![image-20240928162922858](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/09/28_16_29_23_202409281629420.png)

如上图a所示，==内存条插槽就是存储器总线==，内存条中的信息通过内存条的引脚，再通过插槽内的引线连接到主板上，通过主板上的导线连接到北桥芯片或CPU芯片。

现在的计算机中可以有多条存储器总线同时进行数据传输，支持两条总线同时进行传输的内存条插槽为双通道内存插槽，还有三通道、四通道内存插槽，其总线的传输带宽可以分别提高到单通道的两倍、三倍和四倍。例如，上图所示的内存条插槽支持双通道内存条，相同颜色的插槽可以并行传输，因此，对于上图所示的内存条插槽情况，如果只有两个内存条，则应该插在两个颜色相同的内存条插槽上，其传输带宽可以增大一倍。

由若干个存储器芯片构成一个存储器时，需要在字方向和位方向上进行扩展。

- *`位`扩展*指用若干片位数较少的存储器芯片构成给定字长的存储器。例如，用8片`4K×1`位的芯片构成`4K×8`位的存储器，需在位方向上扩展8倍，而字方向上无须扩展。（==横向拓展==）
- *`字`扩展*是容量的扩充，位数不变。例如，用`16K×8`位的存储芯片在字方向上扩展4倍，构成一个`64K×8`位的存储器。当芯片在容量和位数上都不满足存储器要求的情况下，需要对字和位同时扩展。例如，用16K×4位的存储器芯片在字方向上扩展4倍、位方向上扩展2倍，可构成一个64K×8位的存储器。（==纵向拓展==）

> 栗子：
>
> 用8个`16M×8`位(16MB)的DRAM芯片扩展构成一个`128MB`内存条的示意图。每片DRAM芯片中有一个`4096×4096×8`位的存储阵列，所以，行地址和列地址各12位($2^{12} = 4096$),有8个位平面。使用字扩展（==纵向拓展==）对容量进行扩容。
>
> ![DRAM芯片的拓展](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/09/28_16_47_23_202409281647906.png)
>
> 换算关系
> $$
> 16MB = 16M \times 8bit = 2^{24} \times 8bit =2^{12} \times 2^{12} \times 8bit = 4096 \times 4096 \times 8bit
> $$
> 内存条通过存储器总线连接到存储控制器，CPU通过存储控制器对内存条中的DRAM芯片进行读写，CPU要读写的存储单元地址通过总线被送到存储控制器，然后由存储控制器将存储单元地址转换为DRAM芯片的行地址i和列地址j,分别在行地址选通信号RAS和列地址选通信号CAS的控制下，通过DRAM芯片的地址引脚，分时送到DRAM芯片内部的行地址译码器和列地址译码器，以选择行、列地址交叉点(i，j)的8位数据同时进行读写，8个芯片就可同时读取64位，组合成总线所需要的64位传输宽度，再通过存储器总线进行传输。
>
> 现代通用计算机大多按==字节==编址，因此，在图中的存储器结构中，同时读出的64位可能是第0 ~ 7单元、第8 ~ 15单元、…、第8×k~ 8×k+7单元，以此类推。因此，如果访问的一个int型数据不对齐，假定在第6、7、8、9这四个存储单元中，则需要访问两次存储器；如果数据对齐的话，即起始地址是4的倍数，则只要访问一次即可。这就是数据需要对齐的原因。

若一个$2^{n} \times b$位DRAM芯片的存储阵列是`r`行×`c`列，则该芯片容量为$2^{n}\times b$位且$2^{n}=r\times c$,芯片内的地址位数为n,其中行地址位数为$log_2r$,列地址位数为$log_2c$,n位地址中==高位部分为行地址，低位部分为列地址==。为提高DRAM芯片的性价比，通常设置的r和c满足r≤c且r-c最小。例如，对于8K×8位DRAM芯片，其存储阵列设置为2行×2列，因此行地址和列地址的位数分别为6位和7位，13位芯片内地址A~12~A~11~…A~1~A~0~。中，行地址为A~12~...A~7~,列地址为A~6~…A~1~A~0~。

下图是DRAM芯片内部结构示意图。图中芯片容量为16×8位，存储阵列为4行×4列，地址引脚采用复用方式，因而仅需2根地址引脚，在RAS和CAS的控制下分时传送2位行地址和2位列地址。每个超元(supercell)有8位，需8根数据引脚，有一个内部行缓冲(row buffer),用来缓存指定行中每一列的数据，通常用SRAM元件实现。

![DRAM芯片内部结构示意图](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/09/28_19_13_37_202409281913591.png)

下图是DRAM芯片读写原理示意图。图a反映存储控制器在RAS有效时将行地址“2”送到行译码器后选中第“2”行时的状态，此时，整个一行数据被送到内部行缓冲中。图b反映存储控制器在CAS有效时将列地址“1”送到列译码器后选中第“1”列时的状态，此时，将内部行缓冲中第“1”列的8位数据超元（2,1)读到数据线，并继续向CPU传送。

![image-20240928192010650](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/09/28_19_20_11_202409281920025.png)

### 装入指令和存储指令操作过程

访存指令主要有两类：

1. 装入(load)指令：用于将存储单元内容装入CPU的寄存器中，如IA-32中的`movl 8(%ebp),%eax`指令等；
2. 存储（store）指令：用于将CPU寄存器内容存储到存储单元中，如IA-32中的`movl %eax, 8(%ebp)`指令等。

> ==装入指令==
>
> 假定装入指令`movl 8(%ebp),%eax`中存储器操作数`8(%ebp)`对应的主存地址为A,则取数过程为：
>
> 1. CPU将主存地址A通过总线接口送到地址线，然后由存储控制器将地址A分解成行、列地址按分时方式送DRAM芯片；
>
>    ![CPU通过地址线将地址A传送到主存](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_14_13_15_202411061413047.png)
>
> 2. 主存将地址A中的数据x通过数据线送到总线接口部件中；
>
>    ![主存将A中的数据x读出，传送到数据线上](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_14_16_30_202411061416997.png)
>
> 3. CPU从总线接口部件中取出x存放到寄存器EAX中。实际上，上述过程的第一步同时还会把“存储器读”控制命令通过控制线送到主存。
>
>    ![从主存单元取数到寄存器的操作过程](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_14_19_4_202411061419344.png)



> ==存储指令==
>
> 假定存储指令`movl %eax,8(%ebp)`中主存操作数`8(%ebp)`的主存地址为A。则存数的过程为：
>
> 1. CPU将主存地址A通过总线接口送到地址线，然后由存储控制器将地址A分解成行、列地址按分时方式送DRAM芯片；
>
>    ![CPU通过地址线将地址A传送给主存](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_14_24_51_202411061424958.png)
>
> 2. CPU将寄存器EAX中的数据y通过总线接口部件送到数据线；
>
>    ![CPU将数据y传送到数据线](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_14_26_5_202411061426824.png)
>
> 3. 主存将数据线上的y存到主存单元A中。实际上，上述过程的第一步同时还会把“存储器写'”控制命令通过控制线送到主存。而且，第二步将数据y送数据线也可以和第一步同时进行。
>
>    ![主存将数y存放到主存单元A中](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_14_28_27_202411061428492.png)

## 硬盘存储器

### 磁盘存储器结构

磁盘存储器主要由以下部件组成：

1. 磁记录介质
2. 磁盘驱动器：磁盘驱动器包括读写电路、读/写转换开关、读/写磁头与磁头定位伺服系统。
3. 磁盘控制器：磁盘控制器(disk controller)包括控制逻辑、时序电路、“并→串”转换和“串→并”转换电路

![磁盘驱动器的物理组成](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_14_35_13_202411061435294.png)

磁盘驱动器主要由多张硬盘片、主轴、主轴电机、移动臂、磁头和控制电路等部分组成，通过接口与磁盘控制器连接。

- 每个盘片的两个面上各有一个磁头，因此，磁头号就是盘面号。

  ![盘面](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_15_1_51_202411061501172.png)

- 磁头和盘片相对运动形成的圆构成一个磁道(tack),磁头位于不同的半径上，则得到不同的磁道。

- 信息存储在盘面的磁道上，而每个磁道被分成若干扇区(sector),以扇区为单位进行磁盘读写。

  ![扇区](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241106150241759.png)

- 多个盘片上相同磁道形成一个柱面(cylinder),所以，磁道号就是柱面号。

  ![柱面](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_15_3_45_202411061503735.png)

- 在读写磁盘时，总是写完一个柱面上所有的磁道后，再移到下一个柱面。磁道从外向里编址，==最外面的为磁道0==。

磁盘读写是指根据主机访问控制字中的盘地址（柱面号、磁头号、扇区号）读写目标磁道中的指定扇区。因此，其操作可归纳为寻道、旋转等待和读写三个步骤。

1. 寻道操作：磁盘控制器把盘地址送到磁盘驱动器的磁盘地址寄存器后，便产生==寻道命令==，启动磁头定位伺服系统，根据磁头号和柱面号，选择指定的磁头移动到指定的柱面。此操作完成后，发出寻道结束信号给磁盘控制器，并转入旋转等待操作。
2. 旋转等待操作：盘片旋转时，首先将扇区计数器清零，以后每来一个扇区标志脉冲，扇区计数器加1，把计数内容与磁盘地址寄存器中的扇区地址进行比较，如果一致，则输出扇区符合信号，说明要读写的信息已经转到磁头下方。
3. 读写操作：扇区符合信号送给磁盘控制器后，磁盘控制器的读写控制电路开始动作。如果是写操作，就将数据送到写入电路，写入电路根据记录方式生成相应的写电流脉冲；如果是读操作，则由读出放大电路读出内容送磁盘控制器。

![磁盘驱动器的内部逻辑结构](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_15_6_36_202411061506264.png)

磁盘控制器是主机与磁盘驱动器之间的接口。磁盘存储器是高速外设，所以磁盘控制器和主机之间采用成批数据交换方式。

数据在磁盘上的记录格式分定长记录格式和不定长记录格式两种。目前大多采用定长记录格式。最早的硬盘由BM公司开发，称为温切斯特盘(Winchester是一个地名)，简称温盘，它是几乎所有现代硬盘产品的原型，它采用定长记录格式。

![温切斯特磁盘的磁道记录格式](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_15_18_17_202411061518826.png)



温切斯特盘的每个磁道由若干个扇区（也称扇段）组成，每个扇区记录一个数据块，每个扇区由头空（间隙1）、ID域、间隙2、数据域和尾空（间隙3）组成。头空占17个字节，不记录数据，用全1表示，磁盘转过该区域的时间是留给磁盘控制器作准备用的；D域由同步字节、磁道号、磁头号、扇段号和相应的CRC码组成，同步字节标志D域的开始；数据域占515个字节，由同步字节、数据和相应的CRC码组成，其中真正的数据区占512字节；尾空是在数据块的CRC码后的区域，占20个字节，也用全1表示。

### 磁盘存储器的连接

现代计算机中，通常将复杂的磁盘物理扇区抽象成固定大小的逻辑块，物理扇区和逻辑块之间的映射由磁盘控制器来维护。磁盘控制器是一个内置固件的硬件设备，它能将主机送来的请求逻辑块号转换为磁盘的物理地址（柱面号、磁头号、扇区号），并控制磁盘驱动器进行相应的动作。

![磁盘与CPU、主存的连接](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/6_15_26_12_202411061526646.png)

磁盘控制器连接在I/O总线上，I/O总线与其他系统总线（如处理器总线、存储器总线)之间用桥接器连接。磁盘驱动器与磁盘控制器之间的接口有多种，一般文件服务器使用SCSI接口，而普通的PC前些年多使用==并行ATA(即IDE)接口==，目前大多使用==串行ATA(即SATA)接口==。

磁盘与主机交换数据的最小单位是扇区，因此，磁盘总是按成批数据交换方式进行读写，这种高速成批数据交换设备采用直接存储器存取(Direct Memory Access,DMA)方式进行数据的输入输出。该输入输出方式用专门的DMA接口硬件来控制外设与主存间的直接数据交换，数据不通过CPU。通常把专门用来控制总线进行DMA传送的接口硬件称为DMA控制器。在进行DMA传送时，CPU让出总线控制权，由DMA控制器控制总线，通过“窃取”一个主存周期完成和主存之间的一次数据交换，或独占若干个主存周期完成一批数据的交换。

































